--[[
  Panda Assist ‚Äî Follow + Attack (client-side) v2
  - Singleton guard + hard cleanup (X) to prevent duplicate loops/prints
  - Compact, draggable, minimizable UI
  - Status line shows: "Follow: On/Off | Attack: On/Off"
  - "follow me" and "stay" via legacy .Chatted (stable across experiences)
  - Follow chooses first matching name in Targets, else last "follow me" speaker
  - Attack chases nearest of comma-separated names and activates your tool in range
  - Stall fallback if MoveTo is blocked; respawn-safe and UI persists
  - Preflight checks essentials and warns if tool not found

  Use only in experiences you own or have permission for.
]]

-- Singleton: clean any previous instance
if _G.PandaAssistCleanup then
    pcall(_G.PandaAssistCleanup)
    _G.PandaAssistCleanup = nil
end

--// Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

--// Locals
local LP = Players.LocalPlayer
local PlayerGui = LP:WaitForChild("PlayerGui")

--// Config
local FOLLOW_MIN_DIST = 6
local FOLLOW_REENGAGE_DIST = 10
local ATTACK_RANGE = 9
local MOVE_POLL_HZ = 15
local TOOL_ACTIVATE_COOLDOWN = 0.4
local PREFLIGHT_WAIT_SECS = 3
local STALL_WINDOW = 1.2 -- seconds without closing distance -> switch to Move() fallback

--// State
local gui, frame, btnFollow, btnAttack, txtTargets, lblStatus, btnMin, btnClose
local isFollowing = false
local isAttacking = false
local minimized = false
local followTarget = nil           -- Player or nil
local lastFollowSpeaker = nil      -- Player or nil (from "follow me")
local targetList = {}
local lastActivateTime = 0
local connHeartbeat, connCharAdded = nil, nil
local chatConnections = {}
local preflightOk = false
local dead = false -- set to true on hard close

-- Stall tracking
local lastDist = nil
local lastDistTime = 0

--// Utilities
local function getCharParts(p)
    local char = p.Character or p.CharacterAdded:Wait()
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChildOfClass("Humanoid")
    return char, hrp, hum
end

local function getMyParts()
    return getCharParts(LP)
end

local function alive(p)
    local char = p.Character
    if not char then return false end
    local hum = char:FindFirstChildOfClass("Humanoid")
    return hum and hum.Health > 0
end

local function distance(a, b)
    return (a - b).Magnitude
end

local function colorize(button, on)
    button.BackgroundColor3 = on and Color3.fromRGB(46, 204, 113) or Color3.fromRGB(231, 76, 60)
end

local function setStatusText()
    local f = isFollowing and "On" or "Off"
    local a = isAttacking and "On" or "Off"
    lblStatus.Text = "Follow: " .. f .. " | Attack: " .. a
end

local function safeEquipAnyTool()
    local char, _, hum = getMyParts()
    if not char or not hum then return end
    local backpack = LP:FindFirstChildOfClass("Backpack")
    local tool = char:FindFirstChildOfClass("Tool")
    if not tool and backpack then
        tool = backpack:FindFirstChildOfClass("Tool")
        if tool then
            tool.Parent = char
        end
    end
end

local function tryActivateTool()
    local now = time()
    if now - lastActivateTime < TOOL_ACTIVATE_COOLDOWN then return end
    lastActivateTime = now
    local char = LP.Character
    if not char then return end
    local tool = char:FindFirstChildOfClass("Tool")
    if tool and tool.Activate then
        pcall(function() tool:Activate() end)
    end
end

local function listToPlayers(input)
    local out = {}
    local seen = {}
    for name in string.gmatch(input or "", "([^,%s]+)") do
        local needle = name:lower()
        for _, p in ipairs(Players:GetPlayers()) do
            if not seen[p] then
                if p.Name:lower() == needle or (p.DisplayName and p.DisplayName:lower() == needle) then
                    table.insert(out, p)
                    seen[p] = true
                end
            end
        end
    end
    return out
end

local function nearestOf(list)
    local _, myHRP = getMyParts()
    if not myHRP then return nil end
    local bestP, bestD = nil, math.huge
    for _, p in ipairs(list) do
        if p ~= LP and alive(p) then
            local _, hrp = getCharParts(p)
            if hrp then
                local d = distance(myHRP.Position, hrp.Position)
                if d < bestD then
                    bestD, bestP = d, p
                end
            end
        end
    end
    return bestP
end

--// Follow/Attack control
local function setFollowTarget(p)
    followTarget = p
    isFollowing = p ~= nil
    colorize(btnFollow, isFollowing)
    setStatusText()
end

local function setAttack(on)
    isAttacking = on
    colorize(btnAttack, isAttacking)
    setStatusText()
end

local function refreshTargets()
    targetList = listToPlayers(txtTargets.Text)
end

--// Movement loop
local function moveLoop(dt)
    if not preflightOk or dead then return end

    local myChar, myHRP, myHum = getMyParts()
    if not (myChar and myHRP and myHum and myHum.Health > 0) then return end

    local didMove = false

    -- Follow
    if isFollowing and followTarget and alive(followTarget) then
        local _, tHRP = getCharParts(followTarget)
        if tHRP then
            local d = distance(myHRP.Position, tHRP.Position)
            if d > FOLLOW_REENGAGE_DIST then
                -- aim slightly behind to avoid bumping
                local dir = (tHRP.Position - myHRP.Position).Unit
                local targetPos = tHRP.Position - dir * math.min(2, d - FOLLOW_MIN_DIST)
                myHum:MoveTo(targetPos)
                didMove = true
            elseif d < FOLLOW_MIN_DIST then
                myHum:Move(Vector3.new())
            end

            -- stall fallback
            if lastDist then
                if d >= lastDist - 0.05 then
                    if time() - lastDistTime > STALL_WINDOW then
                        local dir = (tHRP.Position - myHRP.Position)
                        if dir.Magnitude > 0.5 then
                            myHum:Move(dir.Unit)
                            didMove = true
                            lastDistTime = time()
                        end
                    end
                else
                    lastDistTime = time()
                end
            else
                lastDistTime = time()
            end
            lastDist = d
        end
    end

    -- Attack
    if isAttacking then
        if #targetList == 0 then
            refreshTargets()
        end
        local target = nearestOf(targetList)
        if target and alive(target) then
            local _, tHRP = getCharParts(target)
            if tHRP then
                local d = distance(myHRP.Position, tHRP.Position)
                myHum:MoveTo(tHRP.Position)
                didMove = true
                if d <= ATTACK_RANGE then
                    safeEquipAnyTool()
                    tryActivateTool()
                end

                -- stall fallback for attack chase
                if lastDist then
                    if d >= lastDist - 0.05 then
                        if time() - lastDistTime > STALL_WINDOW then
                            local dir = (tHRP.Position - myHRP.Position)
                            if dir.Magnitude > 0.5 then
                                myHum:Move(dir.Unit)
                                didMove = true
                                lastDistTime = time()
                            end
                        end
                    else
                        lastDistTime = time()
                    end
                else
                    lastDistTime = time()
                end
                lastDist = d
            end
        end
    end

    if not didMove then
        -- decay stall tracking when idle
        lastDist = nil
    end
end

--// UI
local function makeUI()
    gui = Instance.new("ScreenGui")
    gui.Name = "PandaAssist"
    gui.ResetOnSpawn = false
    gui.IgnoreGuiInset = true
    gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    gui.Parent = PlayerGui

    frame = Instance.new("Frame")
    frame.Name = "Panel"
    frame.Size = UDim2.fromOffset(280, 138)
    frame.Position = UDim2.new(0, 20, 0, 90)
    frame.BackgroundColor3 = Color3.fromRGB(24, 24, 28)
    frame.BorderSizePixel = 0
    frame.Parent = gui
    Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 8)

    local titleBar = Instance.new("Frame")
    titleBar.Name = "TitleBar"
    titleBar.Size = UDim2.new(1, 0, 0, 28)
    titleBar.BackgroundColor3 = Color3.fromRGB(34, 34, 42)
    titleBar.BorderSizePixel = 0
    titleBar.Parent = frame

    local title = Instance.new("TextLabel")
    title.Name = "Title"
    title.Size = UDim2.new(1, -70, 1, 0)
    title.Position = UDim2.new(0, 10, 0, 0)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.GothamBold
    title.TextSize = 14
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.TextColor3 = Color3.fromRGB(236, 240, 241)
    title.Text = "üêº Panda Assist"
    title.Parent = titleBar

    -- Minimize
    btnMin = Instance.new("TextButton")
    btnMin.Name = "Minimize"
    btnMin.Size = UDim2.fromOffset(28, 20)
    btnMin.Position = UDim2.new(1, -66, 0.5, -10)
    btnMin.BackgroundColor3 = Color3.fromRGB(52, 73, 94)
    btnMin.AutoButtonColor = true
    btnMin.TextColor3 = Color3.fromRGB(236, 240, 241)
    btnMin.Font = Enum.Font.GothamBold
    btnMin.TextSize = 12
    btnMin.Text = "‚Äî"
    btnMin.Parent = titleBar
    Instance.new("UICorner", btnMin).CornerRadius = UDim.new(0, 6)

    -- Close (hard cleanup)
    btnClose = Instance.new("TextButton")
    btnClose.Name = "Close"
    btnClose.Size = UDim2.fromOffset(28, 20)
    btnClose.Position = UDim2.new(1, -34, 0.5, -10)
    btnClose.BackgroundColor3 = Color3.fromRGB(192, 57, 43)
    btnClose.AutoButtonColor = true
    btnClose.TextColor3 = Color3.fromRGB(236, 240, 241)
    btnClose.Font = Enum.Font.GothamBold
    btnClose.TextSize = 12
    btnClose.Text = "X"
    btnClose.Parent = titleBar
    Instance.new("UICorner", btnClose).CornerRadius = UDim.new(0, 6)

    local body = Instance.new("Frame")
    body.Name = "Body"
    body.Size = UDim2.new(1, -16, 1, -44)
    body.Position = UDim2.new(0, 8, 0, 36)
    body.BackgroundTransparency = 1
    body.Parent = frame

    btnFollow = Instance.new("TextButton")
    btnFollow.Name = "Follow"
    btnFollow.Size = UDim2.fromOffset(130, 28)
    btnFollow.Position = UDim2.new(0, 0, 0, 0)
    btnFollow.BorderSizePixel = 0
    btnFollow.TextColor3 = Color3.fromRGB(255, 255, 255)
    btnFollow.Font = Enum.Font.GothamBold
    btnFollow.TextSize = 14
    btnFollow.Text = "Follow"
    btnFollow.Parent = body
    colorize(btnFollow, false)
    Instance.new("UICorner", btnFollow).CornerRadius = UDim.new(0, 6)

    btnAttack = Instance.new("TextButton")
    btnAttack.Name = "Attack"
    btnAttack.Size = UDim2.fromOffset(130, 28)
    btnAttack.Position = UDim2.new(0, 134, 0, 0)
    btnAttack.BorderSizePixel = 0
    btnAttack.TextColor3 = Color3.fromRGB(255, 255, 255)
    btnAttack.Font = Enum.Font.GothamBold
    btnAttack.TextSize = 14
    btnAttack.Text = "Attack"
    btnAttack.Parent = body
    colorize(btnAttack, false)
    Instance.new("UICorner", btnAttack).CornerRadius = UDim.new(0, 6)

    txtTargets = Instance.new("TextBox")
    txtTargets.Name = "Targets"
    txtTargets.Size = UDim2.new(1, 0, 0, 28)
    txtTargets.Position = UDim2.new(0, 0, 0, 36)
    txtTargets.BackgroundColor3 = Color3.fromRGB(44, 62, 80)
    txtTargets.BorderSizePixel = 0
    txtTargets.PlaceholderText = "Targets: username1, username2"
    txtTargets.Text = ""
    txtTargets.TextColor3 = Color3.fromRGB(236, 240, 241)
    txtTargets.Font = Enum.Font.Gotham
    txtTargets.TextSize = 14
    txtTargets.ClearTextOnFocus = false
    txtTargets.Parent = body
    Instance.new("UICorner", txtTargets).CornerRadius = UDim.new(0, 6)

    lblStatus = Instance.new("TextLabel")
    lblStatus.Name = "Status"
    lblStatus.Size = UDim2.new(1, 0, 0, 24)
    lblStatus.Position = UDim2.new(0, 0, 0, 70)
    lblStatus.BackgroundTransparency = 1
    lblStatus.TextColor3 = Color3.fromRGB(189, 195, 199)
    lblStatus.Font = Enum.Font.Gotham
    lblStatus.TextSize = 13
    lblStatus.TextXAlignment = Enum.TextXAlignment.Left
    lblStatus.Text = "Preflight running..."
    lblStatus.Parent = body

    -- Draggable via title bar
    local dragging, dragStart, startPos = false, nil, nil
    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local delta = input.Position - dragStart
            frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)

    -- Minimize
    btnMin.MouseButton1Click:Connect(function()
        minimized = not minimized
        btnMin.Text = minimized and "+" or "‚Äî"
        for _, child in ipairs(frame:GetChildren()) do
            if child.Name == "Body" then
                child.Visible = not minimized
            end
        end
        frame.Size = minimized and UDim2.fromOffset(280, 28) or UDim2.fromOffset(280, 138)
    end)
end

--// Connections and chat
local function disconnectChats()
    for _, c in ipairs(chatConnections) do
        if c and c.Disconnect then pcall(function() c:Disconnect() end) end
    end
    chatConnections = {}
end

local function onChatMessage(speaker, text)
    if not text then return end
    local lower = string.lower(text)
    if string.find(lower, "follow me", 1, true) then
        if speaker and speaker ~= LP then
            lastFollowSpeaker = speaker
            setFollowTarget(speaker)
        end
    elseif string.match(lower, "^%s*stay%s*$") or string.find(lower, " stay ", 1, true) or string.find(lower, " stay!", 1, true) then
        setFollowTarget(nil)
    end
end

local function connectChat()
    disconnectChats()
    for _, p in ipairs(Players:GetPlayers()) do
        table.insert(chatConnections, p.Chatted:Connect(function(text)
            onChatMessage(p, text)
        end))
    end
    table.insert(chatConnections, Players.PlayerAdded:Connect(function(p)
        table.insert(chatConnections, p.Chatted:Connect(function(text)
            onChatMessage(p, text)
        end))
    end))
end

--// Preflight
local function preflight()
    local errors, warnings = {}, {}

    -- Character & parts
    local deadline = time() + PREFLIGHT_WAIT_SECS
    local char = LP.Character
    while time() < deadline and not char do task.wait(0.05) char = LP.Character end
    if not char then table.insert(errors, "Character not available.") end

    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    local end2 = time() + PREFLIGHT_WAIT_SECS
    while time() < end2 and (not hrp or not hum) do
        task.wait(0.05)
        hrp = char and char:FindFirstChild("HumanoidRootPart")
        hum = char and char:FindFirstChildOfClass("Humanoid")
    end
    if not hrp then table.insert(errors, "HumanoidRootPart not found.") end
    if not hum then table.insert(errors, "Humanoid not found.") end

    -- Movement availability
    if hum and typeof(hum.MoveTo) ~= "function" then table.insert(errors, "Humanoid:MoveTo unavailable.") end
    if hum and hum.WalkSpeed <= 0 then table.insert(warnings, "WalkSpeed is 0; movement may not occur.") end

    -- UI mount
    if not PlayerGui or not PlayerGui.Parent then table.insert(errors, "PlayerGui not available.") end

    -- Tool presence (soft)
    local hasTool = false
    if char and char:FindFirstChildOfClass("Tool") then hasTool = true end
    local backpack = LP:FindFirstChildOfClass("Backpack")
    if backpack and backpack:FindFirstChildOfClass("Tool") then hasTool = true end
    if not hasTool then table.insert(warnings, "No tool detected; Attack may not trigger damage/effects.") end

    if #errors > 0 then
        return false, errors[1], warnings
    end
    return true, nil, warnings
end

--// Wiring
local function bindCharacter(char)
    if connHeartbeat then connHeartbeat:Disconnect() connHeartbeat = nil end
    -- reset stall trackers on respawn
    lastDist, lastDistTime = nil, 0
    task.delay(0.15, function()
        if dead then return end
        connHeartbeat = RunService.Heartbeat:Connect(function(dt)
            -- throttle to MOVE_POLL_HZ
            local step = 1 / MOVE_POLL_HZ
            bindCharacter._acc = (bindCharacter._acc or 0) + dt
            while bindCharacter._acc >= step do
                bindCharacter._acc -= step
                moveLoop(step)
            end
        end)
    end)
end

local function cleanup()
    if dead then return end
    dead = true
    disconnectChats()
    if connHeartbeat then pcall(function() connHeartbeat:Disconnect() end) end
    if connCharAdded then pcall(function() connCharAdded:Disconnect() end) end
    if gui then pcall(function() gui:Destroy() end) end
    _G.PandaAssistCleanup = nil
end

local function init()
    makeUI()
    -- Close button after UI exists
    btnClose.MouseButton1Click:Connect(cleanup)

    -- Button logic
    btnFollow.MouseButton1Click:Connect(function()
        if not preflightOk or dead then return end
        if isFollowing then
            setFollowTarget(nil)
        else
            -- Priority: explicit target in box -> last speaker -> none
            local list = listToPlayers(txtTargets.Text)
            if list[1] then
                setFollowTarget(list[1])
            elseif lastFollowSpeaker and lastFollowSpeaker.Parent then
                setFollowTarget(lastFollowSpeaker)
            else
                setFollowTarget(nil)
            end
        end
    end)

    btnAttack.MouseButton1Click:Connect(function()
        if not preflightOk or dead then return end
        if isAttacking then
            setAttack(false)
        else
            refreshTargets()
            setAttack(true)
        end
    end)

    txtTargets.FocusLost:Connect(function()
        refreshTargets()
    end)

    -- Preflight
    local ok, reason, warns = preflight()
    preflightOk = ok
    if not ok then
        colorize(btnFollow, false)
        colorize(btnAttack, false)
        btnFollow.AutoButtonColor = false; btnFollow.Active = false
        btnAttack.AutoButtonColor = false; btnAttack.Active = false
        lblStatus.Text = "Preflight failed: " .. (reason or "Unknown")
        -- one-time print
        warn("[PandaAssist] Preflight failed: " .. tostring(reason))
    else
        setStatusText()
        if warns and #warns > 0 then
            warn("[PandaAssist] Ready with warnings:")
            for _, w in ipairs(warns) do warn(" - " .. w) end
        else
            print("[PandaAssist] Ready.")
        end
        connectChat()
        if LP.Character then bindCharacter(LP.Character) end
        if connCharAdded then pcall(function() connCharAdded:Disconnect() end) end
        connCharAdded = LP.CharacterAdded:Connect(function(char)
            if dead then return end
            bindCharacter(char)
        end)
    end

    -- Auto-clean on leave
    LP.AncestryChanged:Connect(function(_, parent)
        if not parent then cleanup() end
    end)
end

_G.PandaAssistCleanup = cleanup
init()
