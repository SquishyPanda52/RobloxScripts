--[[
  Hilton Executor UI — Follow + Attack (Client-Only)
  - No server/chat hooks. Pure runtime local logic.
  - Follow and Attack are mutually exclusive.
  - Follow auto-disables on death (you or target). Attack does not auto-disable.
  - Draggable, compact UI with minimize (—/+) and hard close (X).
  - Buttons show On/Off and color (green/red). Partial name matching supported.

  Paste into your executor. Re-running replaces any previous instance cleanly.
]]

-- Singleton cleanup (prevent duplicates)
if _G.HiltonExec and _G.HiltonExec.Cleanup then
    pcall(_G.HiltonExec.Cleanup)
end
_G.HiltonExec = { }

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local localPlayer = Players.LocalPlayer
local playerGui = localPlayer:WaitForChild("PlayerGui")

-- State
local gui, mainFrame, titleBar, minBtn, closeBtn
local content, followRow, followBtn, followBox
local attackRow, attackBtn, attackBox
local isMinimized = false

local followEnabled = false
local followTargetName = ""
local followTargetPlayer = nil
local attackEnabled = false
local attackNames = {}

local followConn, attackConn
local connections = {}

-- Utils
local function trim(s) return (s:gsub("^%s+", ""):gsub("%s+$", "")) end

local function setBtnState(btn, on, label)
    btn.Text = label .. ": " .. (on and "On" or "Off")
    btn.BackgroundColor3 = on and Color3.fromRGB(46, 204, 113) or Color3.fromRGB(231, 76, 60)
end

local function findClosestPlayer(fragment)
    fragment = trim(fragment or ""):lower()
    if fragment == "" then return nil end
    local best, bestScore
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= localPlayer then
            local nm = pl.Name:lower()
            -- Prefer substring match
            if nm:find(fragment, 1, true) then
                return pl
            end
            -- Fallback: length difference heuristic
            local score = math.abs(#nm - #fragment)
            if not bestScore or score < bestScore then
                bestScore, best = score, pl
            end
        end
    end
    return best
end

local function parseAttackNames(text)
    attackNames = {}
    for name in tostring(text or ""):gmatch("([^,]+)") do
        name = trim(name)
        if #name > 0 then table.insert(attackNames, name) end
    end
end

local function getHRP(p)
    local char = p.Character
    if not char then return nil end
    return char:FindFirstChild("HumanoidRootPart")
end

local function getHumanoid(p)
    local char = p.Character
    if not char then return nil end
    return char:FindFirstChildOfClass("Humanoid")
end

-- Follow routine
local function stopFollow()
    followEnabled = false
    followTargetPlayer = nil
    if followConn then followConn:Disconnect() followConn = nil end
    setBtnState(followBtn, false, "Follow")
end

local function startFollow()
    if followConn then followConn:Disconnect() followConn = nil end
    followConn = RunService.Heartbeat:Connect(function()
        if not followEnabled or not followTargetPlayer then return end

        local myChar = localPlayer.Character
        local myHum = myChar and myChar:FindFirstChildOfClass("Humanoid")
        local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
        local theirChar = followTargetPlayer.Character
        local theirHum = theirChar and theirChar:FindFirstChildOfClass("Humanoid")
        local theirRoot = theirChar and theirChar:FindFirstChild("HumanoidRootPart")

        -- Auto-disable if either dies or parts missing
        if not (myHum and myRoot and theirHum and theirRoot) or myHum.Health <= 0 or theirHum.Health <= 0 then
            stopFollow()
            return
        end

        local dist = (theirRoot.Position - myRoot.Position).Magnitude
        -- Aim slightly behind target to give space
        if dist > 8 then
            local dir = (theirRoot.Position - myRoot.Position).Unit
            local targetPos = theirRoot.Position - dir * 2
            myHum:MoveTo(targetPos)
        elseif dist < 5 then
            myHum:Move(Vector3.new())
        end
    end)
    table.insert(connections, followConn)
end

-- Attack routine
local function stopAttack()
    attackEnabled = false
    if attackConn then attackConn:Disconnect() attackConn = nil end
    setBtnState(attackBtn, false, "Attack")
end

local function startAttack()
    if attackConn then attackConn:Disconnect() attackConn = nil end
    attackConn = RunService.Heartbeat:Connect(function()
        if not attackEnabled or #attackNames == 0 then return end

        local myChar = localPlayer.Character
        local myHum = myChar and myChar:FindFirstChildOfClass("Humanoid")
        local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
        if not (myHum and myRoot) or myHum.Health <= 0 then
            -- Do NOT auto-disable attack per spec; just wait for respawn/parts
            return
        end

        -- Find nearest valid target among the comma list
        local closestDist, targetPos
        for _, uname in ipairs(attackNames) do
            local pl = findClosestPlayer(uname)
            local hrp = pl and getHRP(pl)
            if hrp then
                local d = (hrp.Position - myRoot.Position).Magnitude
                if not closestDist or d < closestDist then
                    closestDist, targetPos = d, hrp.Position
                end
            end
        end

        if targetPos then
            myHum:MoveTo(targetPos)
        end
    end)
    table.insert(connections, attackConn)
end

-- UI build
local function buildUI()
    gui = Instance.new("ScreenGui")
    gui.Name = "HiltonExecutorUI"
    gui.ResetOnSpawn = false
    gui.IgnoreGuiInset = true
    gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    gui.Parent = playerGui

    mainFrame = Instance.new("Frame")
    mainFrame.Name = "Main"
    mainFrame.Size = UDim2.new(0, 280, 0, 160)
    mainFrame.Position = UDim2.new(0, 40, 0, 120)
    mainFrame.BackgroundColor3 = Color3.fromRGB(28, 28, 32)
    mainFrame.BorderSizePixel = 0
    mainFrame.Parent = gui
    Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 8)
    mainFrame.ClipsDescendants = true

    titleBar = Instance.new("Frame")
    titleBar.Name = "TitleBar"
    titleBar.Size = UDim2.new(1, 0, 0, 30)
    titleBar.BackgroundColor3 = Color3.fromRGB(40, 40, 48)
    titleBar.BorderSizePixel = 0
    titleBar.Parent = mainFrame
    titleBar.ClipsDescendants = true

    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size = UDim2.new(1, -80, 1, 0)
    titleLabel.Position = UDim2.new(0, 10, 0, 0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text = "Admin Executor"
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.TextSize = 14
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.TextColor3 = Color3.fromRGB(235, 235, 235)
    titleLabel.Parent = titleBar

    minBtn = Instance.new("TextButton")
    minBtn.Size = UDim2.new(0, 26, 0, 22)
    minBtn.Position = UDim2.new(1, -62, 0.5, -11)
    minBtn.BackgroundColor3 = Color3.fromRGB(90, 100, 130)
    minBtn.Text = "-"
    minBtn.Font = Enum.Font.GothamBold
    minBtn.TextSize = 14
    minBtn.TextColor3 = Color3.new(1, 1, 1)
    minBtn.Parent = titleBar
    Instance.new("UICorner", minBtn).CornerRadius = UDim.new(0, 6)

    closeBtn = Instance.new("TextButton")
    closeBtn.Size = UDim2.new(0, 26, 0, 22)
    closeBtn.Position = UDim2.new(1, -32, 0.5, -11)
    closeBtn.BackgroundColor3 = Color3.fromRGB(190, 60, 60)
    closeBtn.Text = "X"
    closeBtn.Font = Enum.Font.GothamBold
    closeBtn.TextSize = 14
    closeBtn.TextColor3 = Color3.new(1, 1, 1)
    closeBtn.Parent = titleBar
    Instance.new("UICorner", closeBtn).CornerRadius = UDim.new(0, 6)

    content = Instance.new("Frame")
    content.Name = "Content"
    content.Size = UDim2.new(1, -12, 1, -44)
    content.Position = UDim2.new(0, 6, 0, 36)
    content.BackgroundTransparency = 1
    content.Parent = mainFrame

    local vlist = Instance.new("UIListLayout", content)
    vlist.SortOrder = Enum.SortOrder.LayoutOrder
    vlist.Padding = UDim.new(0, 8)

    -- Follow row
    followRow = Instance.new("Frame")
    followRow.Size = UDim2.new(1, 0, 0, 30)
    followRow.BackgroundTransparency = 1
    followRow.Parent = content

    local fhlist = Instance.new("UIListLayout", followRow)
    fhlist.FillDirection = Enum.FillDirection.Horizontal
    fhlist.SortOrder = Enum.SortOrder.LayoutOrder
    fhlist.Padding = UDim.new(0, 6)

    followBtn = Instance.new("TextButton")
    followBtn.Size = UDim2.new(0, 110, 1, 0)
    followBtn.BackgroundColor3 = Color3.fromRGB(231, 76, 60)
    followBtn.TextColor3 = Color3.new(1, 1, 1)
    followBtn.Font = Enum.Font.GothamBold
    followBtn.TextSize = 14
    followBtn.Text = "Follow: Off"
    followBtn.Parent = followRow
    Instance.new("UICorner", followBtn).CornerRadius = UDim.new(0, 6)

    followBox = Instance.new("TextBox")
    followBox.Size = UDim2.new(1, -116, 1, 0)
    followBox.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
    followBox.PlaceholderText = "Username (partial ok)"
    followBox.Text = ""
    followBox.TextColor3 = Color3.new(1, 1, 1)
    followBox.Font = Enum.Font.Gotham
    followBox.TextSize = 14
    followBox.ClearTextOnFocus = false
    followBox.Parent = followRow
    Instance.new("UICorner", followBox).CornerRadius = UDim.new(0, 6)

    -- Attack row
    attackRow = Instance.new("Frame")
    attackRow.Size = UDim2.new(1, 0, 0, 30)
    attackRow.BackgroundTransparency = 1
    attackRow.Parent = content

    local ahlist = Instance.new("UIListLayout", attackRow)
    ahlist.FillDirection = Enum.FillDirection.Horizontal
    ahlist.SortOrder = Enum.SortOrder.LayoutOrder
    ahlist.Padding = UDim.new(0, 6)

    attackBtn = Instance.new("TextButton")
    attackBtn.Size = UDim2.new(0, 110, 1, 0)
    attackBtn.BackgroundColor3 = Color3.fromRGB(231, 76, 60)
    attackBtn.TextColor3 = Color3.new(1, 1, 1)
    attackBtn.Font = Enum.Font.GothamBold
    attackBtn.TextSize = 14
    attackBtn.Text = "Attack: Off"
    attackBtn.Parent = attackRow
    Instance.new("UICorner", attackBtn).CornerRadius = UDim.new(0, 6)

    attackBox = Instance.new("TextBox")
    attackBox.Size = UDim2.new(1, -116, 1, 0)
    attackBox.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
    attackBox.PlaceholderText = "User1, User2 (partial ok)"
    attackBox.Text = ""
    attackBox.TextColor3 = Color3.new(1, 1, 1)
    attackBox.Font = Enum.Font.Gotham
    attackBox.TextSize = 14
    attackBox.ClearTextOnFocus = false
    attackBox.Parent = attackRow
    Instance.new("UICorner", attackBox).CornerRadius = UDim.new(0, 6)

    -- Dragging (title bar is the handle)
    local dragging, dragStart, startPos = false, nil, nil
    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = mainFrame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then dragging = false end
            end)
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local delta = input.Position - dragStart
            mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)

    -- Minimize
    minBtn.MouseButton1Click:Connect(function()
        isMinimized = not isMinimized
        content.Visible = not isMinimized
        mainFrame.Size = isMinimized and UDim2.new(0, 280, 0, 30) or UDim2.new(0, 280, 0, 160)
        minBtn.Text = isMinimized and "+" or "-"
    end)

    -- Close (hard cleanup)
    closeBtn.MouseButton1Click:Connect(function()
        if _G.HiltonExec and _G.HiltonExec.Cleanup then
            _G.HiltonExec.Cleanup()
        end
    end)
end

-- Button logic (mutually exclusive)
local function onFollowToggle()
    local newState = not followEnabled

    -- If enabling follow, disable attack first
    if newState then
        if attackEnabled then
            stopAttack()
        end
        followTargetName = followBox.Text
        followTargetPlayer = findClosestPlayer(followTargetName)
        if not followTargetPlayer then
            -- No target found, keep off
            setBtnState(followBtn, false, "Follow")
            followEnabled = false
            return
        end
        followEnabled = true
        setBtnState(followBtn, true, "Follow")
        startFollow()
    else
        stopFollow()
    end
end

local function onAttackToggle()
    local newState = not attackEnabled

    -- If enabling attack, disable follow first
    if newState then
        if followEnabled then
            stopFollow()
        end
        parseAttackNames(attackBox.Text)
        if #attackNames == 0 then
            setBtnState(attackBtn, false, "Attack")
            attackEnabled = false
            return
        end
        attackEnabled = true
        setBtnState(attackBtn, true, "Attack")
        startAttack()
    else
        stopAttack()
    end
end

-- Cleanup routine
function _G.HiltonExec.Cleanup()
    -- Disconnect all connections
    pcall(function()
        if followConn then followConn:Disconnect() end
        if attackConn then attackConn:Disconnect() end
        for _, c in ipairs(connections) do
            if c and c.Disconnect then c:Disconnect() end
        end
    end)
    followConn, attackConn = nil, nil

    -- Destroy UI
    if gui then pcall(function() gui:Destroy() end) end

    -- Clear globals
    _G.HiltonExec = nil
end

-- Build UI and wire
buildUI()
table.insert(connections, followBtn.MouseButton1Click:Connect(onFollowToggle))
table.insert(connections, attackBtn.MouseButton1Click:Connect(onAttackToggle))
table.insert(connections, followBox.FocusLost:Connect(function() if followEnabled then onFollowToggle() onFollowToggle() end end))
table.insert(connections, attackBox.FocusLost:Connect(function() if attackEnabled then parseAttackNames(attackBox.Text) end end))

-- Optional: re-run loops safely on respawn (they already handle nils)
table.insert(connections, localPlayer.CharacterAdded:Connect(function()
    -- Nothing special: loops reference current character every tick
end))
