--[[
    Hitbox Executor UI (LocalScript)
    - Client-side only. No server permissions required.
    - Draggable, minimizable UI with ON/OFF color feedback (Green=ON, Red=OFF).
    - Shows everyone else's hitbox with adjustable size.
    - Hitboxes are white with 0.7 transparency (BoxHandleAdornment).
    - Compact layout with constraints and clipping to prevent bleed/overlap.
    - Prints and comments at every step for traceability.
--]]

print("[HitboxUI] Initializing...")

--// Services
local Players = game:GetService("Players")          print("[HitboxUI] Players service ready")
local UserInputService = game:GetService("UserInputService") print("[HitboxUI] UserInputService ready")
local RunService = game:GetService("RunService")    print("[HitboxUI] RunService ready")

--// Locals
local localPlayer = Players.LocalPlayer
local playerGui = localPlayer:WaitForChild("PlayerGui") -- ensure PlayerGui exists
print("[HitboxUI] PlayerGui acquired")

--// State
local hitboxEnabled = false                          -- master toggle
local currentSizeNumber = 3                          -- numeric (studs per axis)
local currentSizeVec3 = Vector3.new(3, 3, 3)        -- vector used by adornments
local adornments = {}                                -- [Character] = BoxHandleAdornment
local connections = {}                               -- connection management per Character
local uiDestroyed = false

--====================================================
-- UI: Build a compact, draggable, minimizable screen
--====================================================
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "HitboxExecutorUI"
screenGui.ResetOnSpawn = false -- persist across respawns
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = playerGui
print("[HitboxUI] ScreenGui created")

local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, 260, 0, 160) -- compact, fixed to avoid bleed
mainFrame.Position = UDim2.new(0.5, -130, 0.5, -80)
mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
mainFrame.BorderSizePixel = 0
mainFrame.ClipsDescendants = true -- prevents child bleed/overlap
mainFrame.Parent = screenGui
print("[HitboxUI] MainFrame created")

local uiCorner = Instance.new("UICorner")
uiCorner.CornerRadius = UDim.new(0, 6)
uiCorner.Parent = mainFrame

local padding = Instance.new("UIPadding")
padding.PaddingLeft = UDim.new(0, 8)
padding.PaddingRight = UDim.new(0, 8)
padding.PaddingTop = UDim.new(0, 8)
padding.PaddingBottom = UDim.new(0, 8)
padding.Parent = mainFrame

local listLayout = Instance.new("UIListLayout")
listLayout.SortOrder = Enum.SortOrder.LayoutOrder
listLayout.Padding = UDim.new(0, 6)
listLayout.Parent = mainFrame

-- Title bar (draggable region)
local titleBar = Instance.new("Frame")
titleBar.Name = "TitleBar"
titleBar.Size = UDim2.new(1, -0, 0, 28)
titleBar.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
titleBar.BorderSizePixel = 0
titleBar.LayoutOrder = 1
titleBar.ClipsDescendants = true
titleBar.Parent = mainFrame

local titleCorner = Instance.new("UICorner")
titleCorner.CornerRadius = UDim.new(0, 6)
titleCorner.Parent = titleBar

local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "Title"
titleLabel.BackgroundTransparency = 1
titleLabel.Size = UDim2.new(1, -60, 1, 0)
titleLabel.Position = UDim2.new(0, 8, 0, 0)
titleLabel.Font = Enum.Font.GothamBold
titleLabel.Text = "Hitbox Executor"
titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
titleLabel.TextSize = 14
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.Parent = titleBar

local titleSizeConstraint = Instance.new("UITextSizeConstraint")
titleSizeConstraint.MaxTextSize = 16
titleSizeConstraint.MinTextSize = 10
titleSizeConstraint.Parent = titleLabel

-- Minimize (-) and Close (X)
local minimizeBtn = Instance.new("TextButton")
minimizeBtn.Name = "Minimize"
minimizeBtn.Size = UDim2.new(0, 26, 0, 26)
minimizeBtn.Position = UDim2.new(1, -58, 0, 1)
minimizeBtn.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
minimizeBtn.BorderSizePixel = 0
minimizeBtn.Text = "-"
minimizeBtn.Font = Enum.Font.GothamBold
minimizeBtn.TextSize = 18
minimizeBtn.TextColor3 = Color3.new(1, 1, 1)
minimizeBtn.Parent = titleBar

local closeBtn = Instance.new("TextButton")
closeBtn.Name = "Close"
closeBtn.Size = UDim2.new(0, 26, 0, 26)
closeBtn.Position = UDim2.new(1, -28, 0, 1)
closeBtn.BackgroundColor3 = Color3.fromRGB(175, 50, 50)
closeBtn.BorderSizePixel = 0
closeBtn.Text = "X"
closeBtn.Font = Enum.Font.GothamBold
closeBtn.TextSize = 14
closeBtn.TextColor3 = Color3.new(1, 1, 1)
closeBtn.Parent = titleBar

-- Controls container
local controls = Instance.new("Frame")
controls.Name = "Controls"
controls.Size = UDim2.new(1, 0, 1, -38)
controls.BackgroundTransparency = 1
controls.BorderSizePixel = 0
controls.LayoutOrder = 2
controls.Parent = mainFrame

local controlsPadding = Instance.new("UIPadding")
controlsPadding.PaddingTop = UDim.new(0, 2)
controlsPadding.Parent = controls

local controlsLayout = Instance.new("UIListLayout")
controlsLayout.SortOrder = Enum.SortOrder.LayoutOrder
controlsLayout.Padding = UDim.new(0, 6)
controlsLayout.Parent = controls

-- Toggle button (color feedback)
local toggleBtn = Instance.new("TextButton")
toggleBtn.Name = "ToggleHitboxes"
toggleBtn.Size = UDim2.new(1, 0, 0, 32)
toggleBtn.BackgroundColor3 = Color3.fromRGB(170, 50, 50) -- RED = OFF initial
toggleBtn.BorderSizePixel = 0
toggleBtn.Text = "Hitboxes OFF"
toggleBtn.Font = Enum.Font.GothamBold
toggleBtn.TextSize = 14
toggleBtn.TextColor3 = Color3.new(1, 1, 1)
toggleBtn.LayoutOrder = 1
toggleBtn.Parent = controls

local toggleCorner = Instance.new("UICorner")
toggleCorner.CornerRadius = UDim.new(0, 4)
toggleCorner.Parent = toggleBtn

-- Size label
local sizeLabel = Instance.new("TextLabel")
sizeLabel.Name = "SizeLabel"
sizeLabel.BackgroundTransparency = 1
sizeLabel.Size = UDim2.new(1, 0, 0, 18)
sizeLabel.Text = "Hitbox Size (studs per axis)"
sizeLabel.Font = Enum.Font.Gotham
sizeLabel.TextSize = 12
sizeLabel.TextColor3 = Color3.fromRGB(210, 210, 210)
sizeLabel.TextXAlignment = Enum.TextXAlignment.Left
sizeLabel.LayoutOrder = 2
sizeLabel.Parent = controls

local sizeLabelConstraint = Instance.new("UITextSizeConstraint")
sizeLabelConstraint.MaxTextSize = 14
sizeLabelConstraint.MinTextSize = 10
sizeLabelConstraint.Parent = sizeLabel

-- Size input
local sizeInput = Instance.new("TextBox")
sizeInput.Name = "SizeInput"
sizeInput.Size = UDim2.new(1, 0, 0, 28)
sizeInput.BackgroundColor3 = Color3.fromRGB(55, 55, 55)
sizeInput.BorderSizePixel = 0
sizeInput.ClearTextOnFocus = false
sizeInput.Text = tostring(currentSizeNumber)
sizeInput.PlaceholderText = "e.g. 4"
sizeInput.Font = Enum.Font.Gotham
sizeInput.TextSize = 14
sizeInput.TextColor3 = Color3.new(1, 1, 1)
sizeInput.TextXAlignment = Enum.TextXAlignment.Left
sizeInput.LayoutOrder = 3
sizeInput.Parent = controls

local sizeInputPadding = Instance.new("UIPadding")
sizeInputPadding.PaddingLeft = UDim.new(0, 8)
sizeInputPadding.Parent = sizeInput

local sizeInputConstraint = Instance.new("UITextSizeConstraint")
sizeInputConstraint.MaxTextSize = 16
sizeInputConstraint.MinTextSize = 10
sizeInputConstraint.Parent = sizeInput

print("[HitboxUI] UI controls created")

--==================
-- Dragging behavior
--==================
local dragging = false
local dragStart, startPos

local function updateDrag(input)
    local delta = input.Position - dragStart
    mainFrame.Position = UDim2.new(
        startPos.X.Scale, startPos.X.Offset + delta.X,
        startPos.Y.Scale, startPos.Y.Offset + delta.Y
    )
end

titleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = mainFrame.Position
        print("[HitboxUI] Drag start")
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
                print("[HitboxUI] Drag end")
            end
        end)
    end
end)

titleBar.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        updateDrag(input)
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        updateDrag(input)
    end
end)

print("[HitboxUI] Draggable logic connected")

--========================
-- Minimize / close logic
--========================
local isMinimized = false
local savedSize = mainFrame.Size

minimizeBtn.MouseButton1Click:Connect(function()
    isMinimized = not isMinimized
    if isMinimized then
        savedSize = mainFrame.Size
        mainFrame.Size = UDim2.new(0, 260, 0, 44) -- show title bar only
        controls.Visible = false
        minimizeBtn.Text = "+"
        print("[HitboxUI] UI minimized")
    else
        mainFrame.Size = savedSize
        controls.Visible = true
        minimizeBtn.Text = "-"
        print("[HitboxUI] UI restored")
    end
end)

closeBtn.MouseButton1Click:Connect(function()
    uiDestroyed = true
    screenGui:Destroy()
    print("[HitboxUI] UI destroyed (script will stop visuals)")
end)

--===================================
-- Hitbox creation / cleanup helpers
--===================================
-- Ensure HumanoidRootPart is available (wait briefly)
local function getHRP(character)
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if hrp then return hrp end
    -- small wait loop to handle fresh spawns
    for i = 1, 50 do -- ~5s max (50 * 0.1s)
        hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then return hrp end
        task.wait(0.1)
    end
    return nil
end

-- Apply a BoxHandleAdornment to a character's HRP
local function applyHitbox(character)
    if uiDestroyed then return end
    if adornments[character] then return end

    local hrp = getHRP(character)
    if not hrp then
        print("[HitboxUI] Skipped (no HRP):", character.Name)
        return
    end

    -- Create adornment
    local box = Instance.new("BoxHandleAdornment")
    box.Name = "HitboxAdornment"
    box.Adornee = hrp
    box.AlwaysOnTop = true
    box.Size = currentSizeVec3
    box.Transparency = 0.7
    box.Color3 = Color3.fromRGB(255, 255, 255) -- white
    box.ZIndex = 0
    box.Parent = hrp -- parent to HRP so it cleans up with the part

    adornments[character] = box
    print("[HitboxUI] Hitbox applied to:", character.Name)

    -- Cleanup if HRP or Character leaves
    local conns = {}
    connections[character] = conns

    conns.AncestryChanged = hrp.AncestryChanged:Connect(function(_, parent)
        if not parent then
            -- HRP removed, cleanup entry if still tracked
            if adornments[character] then
                adornments[character] = nil
                print("[HitboxUI] HRP removed; cleared tracking:", character.Name)
            end
        end
    end)

    if character:IsDescendantOf(workspace) then
        conns.Destroying = character.Destroying:Connect(function()
            if adornments[character] then
                adornments[character] = nil
                print("[HitboxUI] Character destroying; cleared tracking:", character.Name)
            end
        end)
    end
end

-- Remove adornment from a character (if present)
local function removeHitbox(character)
    local box = adornments[character]
    if box then
        box:Destroy()
        adornments[character] = nil
        print("[HitboxUI] Hitbox removed from:", character.Name)
    end
    -- disconnect any character-specific connections
    local conns = connections[character]
    if conns then
        for _, c in pairs(conns) do
            if typeof(c) == "RBXScriptConnection" then
                c:Disconnect()
            end
        end
        connections[character] = nil
    end
end

-- Apply/remove for all other players (exclude local)
local function refreshAll()
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= localPlayer then
            local char = pl.Character
            if char then
                if hitboxEnabled then
                    applyHitbox(char)
                else
                    removeHitbox(char)
                end
            end
        end
    end
end

-- When size changes, propagate to live adornments
local function updateSizes()
    for char, box in pairs(adornments) do
        if box then
            box.Size = currentSizeVec3
        end
    end
    print(string.format("[HitboxUI] Updated size: %.2f,%.2f,%.2f",
        currentSizeVec3.X, currentSizeVec3.Y, currentSizeVec3.Z))
end

--=========================
-- Player/character wiring
--=========================
local function onCharacterAdded(char)
    if uiDestroyed then return end
    print("[HitboxUI] CharacterAdded:", char.Name)
    if hitboxEnabled then applyHitbox(char) end
end

local function onPlayerAdded(pl)
    if pl == localPlayer then return end
    print("[HitboxUI] PlayerAdded:", pl.Name)
    -- bind character lifecycle
    pl.CharacterAdded:Connect(onCharacterAdded)
    if pl.Character then
        onCharacterAdded(pl.Character)
    end
end

local function onPlayerRemoving(pl)
    if pl == localPlayer then return end
    print("[HitboxUI] PlayerRemoving:", pl.Name)
    if pl.Character then removeHitbox(pl.Character) end
end

Players.PlayerAdded:Connect(onPlayerAdded)
Players.PlayerRemoving:Connect(onPlayerRemoving)
for _, pl in ipairs(Players:GetPlayers()) do
    onPlayerAdded(pl)
end
print("[HitboxUI] Player events bound")

--=================
-- UI interactions
--=================
local function setToggleVisuals()
    if hitboxEnabled then
        toggleBtn.BackgroundColor3 = Color3.fromRGB(50, 170, 50) -- GREEN
        toggleBtn.Text = "Hitboxes ON"
    else
        toggleBtn.BackgroundColor3 = Color3.fromRGB(170, 50, 50) -- RED
        toggleBtn.Text = "Hitboxes OFF"
    end
end

toggleBtn.MouseButton1Click:Connect(function()
    hitboxEnabled = not hitboxEnabled
    setToggleVisuals()
    refreshAll()
    print("[HitboxUI] Hitbox toggled:", hitboxEnabled)
end)

sizeInput.FocusLost:Connect(function(enterPressed)
    if not enterPressed then return end
    local raw = sizeInput.Text
    local num = tonumber(raw)
    if num and num > 0 then
        currentSizeNumber = num
        currentSizeVec3 = Vector3.new(num, num, num)
        updateSizes()
        print("[HitboxUI] Accepted size input:", num)
    else
        print("[HitboxUI] Invalid size input:", raw, " -> keeping:", currentSizeNumber)
        sizeInput.Text = tostring(currentSizeNumber)
    end
end)

-- initialize visuals to OFF state
setToggleVisuals()

print("[HitboxUI] UI fully initialized and operational")
