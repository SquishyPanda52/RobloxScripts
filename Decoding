-- === Idle Animation Playback (runtime local, sparse player) ===

local POSE_DATA = {
    note   = "Sparse updates over one loop",
    schema = "sparse+base",
    fps    = 30,
    rig    = "R15",
    joints = {
        "LeftAnkle","LeftElbow","LeftHip","LeftKnee","LeftShoulder","LeftWrist",
        "Neck","RightAnkle","RightElbow","RightHip","RightKnee",
        "RightShoulder","RightWrist","Root","Waist"
    },
    base = {
        Waist          = {0,0,0,1,0,0,0,1,0,0,0,1},
        LeftShoulder   = {0,0,0,0.25882,0.96593,-0,-0.96593,0.25882,-0,-0,0,1},
        Root           = {0,0,0,1,0,0,0,1,0,0,0,1},
        Neck           = {0,0,0,1,-0,-0,0,0.25882,0.96593,-0,-0.96593,0.25882},
        RightWrist     = {0,0,0,1,0,0,0,1,0,0,0,1},
        RightElbow     = {0,0,0,1,0,0,0,1,0,0,0,1},
        RightHip       = {0,0,0,1,0,0,0,1,0,0,0,1},
        RightKnee      = {0,0,0,1,0,0,0,1,0,0,0,1},
        LeftKnee       = {0,0,0,1,0,0,0,1,0,0,0,1},
        RightAnkle     = {0,0,0,1,0,0,0,1,0,0,0,1},
        RightShoulder  = {0,0,0.00001,0.21757,-0.95979,-0.17736,0.17736,0.21757,-0.9598,0.9598,0.17736,0.21757},
        LeftWrist      = {0,0,0,1,0,0,0,1,0,0,0,1},
        LeftElbow      = {0,0,0,1,0,0,0,1,0,0,0,1},
        LeftHip        = {0,0,0,1,0,0,0,1,0,0,0,1},
        LeftAnkle      = {0,0,0,1,0,0,0,1,0,0,0,1}
    },
    updates = {
        {
            i = 1,
            t = 0.075,
            joints = {
                Neck          = {0,0,0,1,-0,-0,0,0,1,-0,-1,0},
                LeftShoulder  = {0,0,0,0,1,-0,-1,0,-0,-0,0,1},
                RightShoulder = {0,0,0.00001,0,-1,-0,-0,0,-1,1,0,-0}
            }
        }
    }
}

-- === Player ===
local Players    = game:GetService("Players")
local RunService = game:GetService("RunService")
local lp         = Players.LocalPlayer

local char = lp.Character or lp.CharacterAdded:Wait()

-- Map Motor6Ds for the joints we care about
local motors = {}
for _, m in ipairs(char:GetDescendants()) do
    if m:IsA("Motor6D") then
        motors[m.Name] = m
    end
end

local function cfFromArray(a)
    return CFrame.new(unpack(a))
end

local function applyPose(pose)
    for joint, arr in pairs(pose) do
        local m = motors[joint]
        if m and arr then
            m.Transform = cfFromArray(arr)
        end
    end
end

-- Apply base immediately
applyPose(POSE_DATA.base)

-- Determine loop length from max update index (fallback 1 if empty)
local totalFrames = 1
if #POSE_DATA.updates > 0 then
    for _, u in ipairs(POSE_DATA.updates) do
        if u.i > totalFrames then totalFrames = u.i end
    end
end

local frameTime = 1 / POSE_DATA.fps

RunService.RenderStepped:Connect(function()
    -- Which frame index are we on in the loop?
    local loopT       = tick() % (totalFrames * frameTime)
    local currentFrame = math.floor(loopT / frameTime) + 1
    -- Apply any updates scheduled for this frame
    for _, upd in ipairs(POSE_DATA.updates) do
        if upd.i == currentFrame then
            applyPose(upd.joints)
        end
    end
end)
