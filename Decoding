--[[ 
Dense CFrame Player â€” client-only
- Plays your captured pose by writing ALL Motor6D.Transforms every frame.
- Disables Animate only during playback; restores it afterward.
- Draggable UI with duration field so you can re-trigger easily.
- Re-exec safe (cleans previous UI/loop).
]]

-- ======= CONFIG =======
local DEFAULT_DURATION = 5.0 -- seconds
local GUI_NAME         = "DenseCFramePlayer_UI"

-- ======= YOUR CAPTURED DATA (dense-ready: base + sparse updates) =======
local POSE_DATA = {
    note   = "Sparse updates over one loop",
    schema = "sparse+base",
    fps    = 30,
    rig    = "R15",
    joints = {
        "LeftAnkle","LeftElbow","LeftHip","LeftKnee","LeftShoulder","LeftWrist",
        "Neck","RightAnkle","RightElbow","RightHip","RightKnee",
        "RightShoulder","RightWrist","Root","Waist"
    },
    base = {
        Waist          = {0,0,0,1,0,0,0,1,0,0,0,1},
        LeftShoulder   = {0,0,0,0.25882,0.96593,-0,-0.96593,0.25882,-0,-0,0,1},
        Root           = {0,0,0,1,0,0,0,1,0,0,0,1},
        Neck           = {0,0,0,1,-0,-0,0,0.25882,0.96593,-0,-0.96593,0.25882},
        RightWrist     = {0,0,0,1,0,0,0,1,0,0,0,1},
        RightElbow     = {0,0,0,1,0,0,0,1,0,0,0,1},
        RightHip       = {0,0,0,1,0,0,0,1,0,0,0,1},
        RightKnee      = {0,0,0,1,0,0,0,1,0,0,0,1},
        LeftKnee       = {0,0,0,1,0,0,0,1,0,0,0,1},
        RightAnkle     = {0,0,0,1,0,0,0,1,0,0,0,1},
        RightShoulder  = {0,0,0.00001,0.21757,-0.95979,-0.17736,0.17736,0.21757,-0.9598,0.9598,0.17736,0.21757},
        LeftWrist      = {0,0,0,1,0,0,0,1,0,0,0,1},
        LeftElbow      = {0,0,0,1,0,0,0,1,0,0,0,1},
        LeftHip        = {0,0,0,1,0,0,0,1,0,0,0,1},
        LeftAnkle      = {0,0,0,1,0,0,0,1,0,0,0,1}
    },
    updates = {
        {
            i = 1,
            t = 0.075,
            joints = {
                Neck          = {0,0,0,1,-0,-0,0,0,1,-0,-1,0},
                LeftShoulder  = {0,0,0,0,1,-0,-1,0,-0,-0,0,1},
                RightShoulder = {0,0,0.00001,0,-1,-0,-0,0,-1,1,0,-0}
            }
        }
    }
}

-- ======= SINGLETON GUARD / CLEANUP =======
getgenv().DENSE_CFRAME_PLAYER = getgenv().DENSE_CFRAME_PLAYER or {}
local S = getgenv().DENSE_CFRAME_PLAYER
if S.stop then pcall(S.stop) end
if S.gui and S.gui.Parent then S.gui:Destroy() end

-- ======= SERVICES =======
local Players     = game:GetService("Players")
local RunService  = game:GetService("RunService")
local StarterGui  = game:GetService("StarterGui")
local lp          = Players.LocalPlayer

-- ======= UTIL =======
local function waitForCharacter(plr)
    local ch = plr.Character
    if ch and ch.Parent then return ch end
    return plr.CharacterAdded:Wait()
end

local function mapMotors(char)
    local t = {}
    for _, d in ipairs(char:GetDescendants()) do
        if d:IsA("Motor6D") then
            t[d.Name] = d
        end
    end
    return t
end

local function cfFromArray(a)
    return CFrame.new(unpack(a))
end

local function applyPose(motors, pose)
    for joint, arr in pairs(pose) do
        local m = motors[joint]
        if m and arr then
            m.Transform = cfFromArray(arr)
        end
    end
end

local function clearTransforms(motors)
    for _, m in pairs(motors) do
        if m.Transform ~= CFrame.identity then
            m.Transform = CFrame.identity
        end
    end
end

local function getAnimate(char)
    return char:FindFirstChild("Animate")
end

-- Build dense frames: a full pose for every frame index, using base + sparse updates (carry-forward)
local function buildDenseFrames(data)
    local fps = data.fps > 0 and data.fps or 30
    local maxI = 1
    for _, u in ipairs(data.updates or {}) do
        if u.i > maxI then maxI = u.i end
    end
    -- Ensure at least one frame
    local totalFrames = math.max(1, maxI)

    -- Sort updates by i
    local updates = {}
    for _, u in ipairs(data.updates or {}) do
        updates[u.i] = updates[u.i] or {}
        table.insert(updates[u.i], u)
    end

    -- Carry-forward pose
    local current = {}
    for j, arr in pairs(data.base or {}) do current[j] = arr end

    local dense = {}
    for f = 1, totalFrames do
        -- Apply any updates scheduled for this frame
        if updates[f] then
            for _, u in ipairs(updates[f]) do
                for j, arr in pairs(u.joints or {}) do
                    current[j] = arr
                end
            end
        end
        -- Snapshot full pose for this frame (shallow copy of arrays is fine: immutable)
        local framePose = {}
        for j, arr in pairs(current) do framePose[j] = arr end
        dense[f] = framePose
    end

    return dense, totalFrames, (1 / fps)
end

-- ======= PLAYER RUNNER =======
local Runner = {
    conn = nil,
    playing = false,
    deadline = 0,
    motors = nil,
    char = nil,
    animate = nil,
    animateWasDisabled = nil,
    dense = nil,
    totalFrames = 1,
    frameTime = 1/30,
    startClock = 0,
}

function Runner:disableAnimate()
    self.animate = getAnimate(self.char)
    if self.animate and self.animate:IsA("LocalScript") then
        self.animateWasDisabled = self.animate.Disabled
        self.animate.Disabled = true
    end
end

function Runner:restoreAnimate()
    if self.motors then clearTransforms(self.motors) end
    if self.animate and self.animate.Parent then
        -- restore original state; then ensure enabled
        if self.animateWasDisabled ~= nil then
            self.animate.Disabled = self.animateWasDisabled
        end
        self.animate.Disabled = false
    end
end

function Runner:start(duration)
    -- Stop existing
    if self.playing then self:stop(true) end

    self.char = waitForCharacter(lp)
    self.motors = mapMotors(self.char)
    self.dense, self.totalFrames, self.frameTime = buildDenseFrames(POSE_DATA)
    self:disableAnimate()

    self.startClock = os.clock()
    self.deadline = self.startClock + (tonumber(duration) or DEFAULT_DURATION)
    self.playing = true

    -- Start: apply first frame immediately
    applyPose(self.motors, self.dense[1])

    self.conn = RunService.RenderStepped:Connect(function()
        if not self.playing then return end

        -- Compute current frame by time
        local loopLen  = self.totalFrames * self.frameTime
        local loopT    = (os.clock() - self.startClock) % loopLen
        local frameIdx = math.floor(loopT / self.frameTime) + 1
        if frameIdx < 1 then frameIdx = 1 end
        if frameIdx > self.totalFrames then frameIdx = self.totalFrames end

        -- APPLY FULL POSE FOR THIS FRAME (writes ALL joints from your CFrames)
        applyPose(self.motors, self.dense[frameIdx])

        -- End condition
        if os.clock() >= self.deadline then
            self:stop(false)
        end
    end)
end

function Runner:stop(isInterrupt)
    if self.conn then self.conn:Disconnect() self.conn = nil end
    self.playing = false
    self:restoreAnimate()
end

S.stop = function()
    if Runner.playing then Runner:stop(true) end
end

-- Ensure Animate re-enables on new spawn if not playing
Players.LocalPlayer.CharacterAdded:Connect(function(ch)
    if not Runner.playing then
        local a = getAnimate(ch)
        if a then a.Disabled = false end
    end
end)

-- ======= UI =======
local pg  = lp:WaitForChild("PlayerGui")
local gui = Instance.new("ScreenGui")
gui.Name = GUI_NAME
gui.ResetOnSpawn = false
gui.IgnoreGuiInset = true
gui.Parent = pg
S.gui = gui

local frame = Instance.new("Frame")
frame.Name = "Panel"
frame.Size = UDim2.new(0, 220, 0, 90)
frame.Position = UDim2.new(1, -240, 1, -140)
frame.BackgroundColor3 = Color3.fromRGB(20, 20, 24)
frame.BorderSizePixel = 0
frame.Parent = gui
Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 8)

local title = Instance.new("TextLabel")
title.BackgroundTransparency = 1
title.Text = "Dense CFrame Player"
title.Font = Enum.Font.GothamBold
title.TextSize = 14
title.TextColor3 = Color3.fromRGB(255, 200, 80)
title.TextXAlignment = Enum.TextXAlignment.Left
title.Size = UDim2.new(1, -10, 0, 20)
title.Position = UDim2.new(0, 10, 0, 6)
title.Parent = frame

local durLabel = Instance.new("TextLabel")
durLabel.BackgroundTransparency = 1
durLabel.Text = "Duration (s):"
durLabel.Font = Enum.Font.Gotham
durLabel.TextSize = 12
durLabel.TextColor3 = Color3.fromRGB(210, 210, 220)
durLabel.TextXAlignment = Enum.TextXAlignment.Left
durLabel.Size = UDim2.new(0, 90, 0, 20)
durLabel.Position = UDim2.new(0, 10, 0, 28)
durLabel.Parent = frame

local durBox = Instance.new("TextBox")
durBox.Size = UDim2.new(0, 60, 0, 20)
durBox.Position = UDim2.new(0, 100, 0, 28)
durBox.Text = tostring(DEFAULT_DURATION)
durBox.ClearTextOnFocus = false
durBox.Font = Enum.Font.Gotham
durBox.TextSize = 12
durBox.TextColor3 = Color3.fromRGB(255, 255, 255)
durBox.BackgroundColor3 = Color3.fromRGB(36, 36, 42)
durBox.Parent = frame
Instance.new("UICorner", durBox).CornerRadius = UDim.new(0, 6)

local btn = Instance.new("TextButton")
btn.Size = UDim2.new(0, 200, 0, 28)
btn.Position = UDim2.new(0, 10, 0, 56)
btn.Text = "Run custom CFrame pose"
btn.Font = Enum.Font.GothamBold
btn.TextSize = 13
btn.TextColor3 = Color3.fromRGB(12, 12, 14)
btn.BackgroundColor3 = Color3.fromRGB(255, 200, 80)
btn.AutoButtonColor = true
btn.Parent = frame
Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 6)

-- Dragging
do
    local UIS = game:GetService("UserInputService")
    local dragging, dragStart, startPos
    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then dragging = false end
            end)
        end
    end)
    UIS.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local delta = input.Position - dragStart
            frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
end

-- Button action
btn.MouseButton1Click:Connect(function()
    local dur = tonumber(durBox.Text)
    if not dur or dur <= 0 then
        dur = DEFAULT_DURATION
        durBox.Text = tostring(dur)
        pcall(function()
            StarterGui:SetCore("SendNotification", {
                Title = "CFrame Player",
                Text  = "Invalid duration. Using default: " .. tostring(dur) .. "s",
                Duration = 2
            })
        end)
    end
    Runner:start(dur)
end)

-- Safety: ensure Animate is enabled if UI is removed
gui.AncestryChanged:Connect(function(_, parent)
    if not parent then
        if Runner.playing then Runner:stop(true) end
        local ch = lp.Character or lp.CharacterAdded:Wait()
        local a = getAnimate(ch)
        if a then a.Disabled = false end
    end
end)
