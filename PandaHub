-------------------------------------------------------------------------------------------------------------------------------------------
-- When you’re creating a mechanic from scratch with code, what really matters is that the code runs on the client, not where it lives in the Explorer.
-- Whether the local script shows up under workspace, PlayerGui, or nowhere at all, as long as it has access to:
-- game.Players.LocalPlayer
-- RunService.RenderStepped (or Heartbeat)
-- The player’s HumanoidRootPart
--
-- Quick Tips
-- To avoid any parent-dependent bugs, use absolute service calls:
--
-- If we ever need the code to act like a true LocalScript (e.g., GUI in PlayerGui), you can forcibly reparent:
-- script.Parent = player:WaitForChild("PlayerGui")
--
-- For maximum stealth and reliability, combine with auto-reparent logic:
-- -- detect where you are, then optionally move
-- if not script:IsDescendantOf(game:GetService("StarterPlayer").StarterPlayerScripts) then
--     script.Parent = game:GetService("StarterPlayer").StarterPlayerScripts
-- end
--
-- Other Frequent Spots
-- Memory-Only (No Visible Parent) — Some code executes purely in memory. You won’t see the script object anywhere in the Explorer.
-- CoreGui — UI-focused code often lands here
-- ReplicatedFirst / ReplicatedStorage — Less common, but sometimes used for client replication
-- StarterPlayerScripts / PlayerScripts — can reparent here to run code as a true LocalScript
-- Try to use Memory-only the most; if necessary use the other mechanics; do StarterPlayerScripts/PlayerScripts the least.
-------------------------------------------------------------------------------------------------------------------------------------------

-- Services (absolute calls)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

-- Locals
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local humanoid = character:WaitForChild("Humanoid")

-- Optional, keep memory-only by default; set to true to force reparenting (not recommended)
local FORCE_PARENTING = false
if FORCE_PARENTING then
    -- Least-preferred path, but available if you need strict LocalScript behavior
    local sps = game:GetService("StarterPlayer"):WaitForChild("StarterPlayerScripts")
    if not script:IsDescendantOf(sps) then
        script.Parent = sps
    end
end

-- Where am I?
print("[MobileFly] script parent:", script.Parent and script.Parent:GetFullName() or "nil (memory-only)")

-- UI root
local screenGuiName = "MobileFlyUI"
-- Clean any previous instance
local existing = (player:FindFirstChild("PlayerGui") and player.PlayerGui:FindFirstChild(screenGuiName)) or nil
if existing then existing:Destroy() end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = screenGuiName
screenGui.DisplayOrder = 9999
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = player:WaitForChild("PlayerGui")

print("[MobileFly] UI parent:", screenGui.Parent and screenGui.Parent:GetFullName() or "nil")

-- Theme
local COLOR_PRIMARY = Color3.fromRGB(0,170,255)
local COLOR_BG = Color3.fromRGB(20,22,26)
local COLOR_ACCENT_GO = Color3.fromRGB(90,190,110)
local COLOR_ACCENT_STOP = Color3.fromRGB(220,110,110)
local COLOR_TEXT = Color3.new(1,1,1)

-- State
local flying = false
local panelOpen = true
local ascendHeld, descendHeld = false, false
local speed = 70            -- planar speed
local verticalSpeed = 50    -- up/down speed
local lastPanelPos = UDim2.new(0.5, -100, 1, -160)

-- Helpers: rounded corners
local function corner(parent, radius)
    local c = Instance.new("UICorner")
    c.CornerRadius = UDim.new(0, radius or 8)
    c.Parent = parent
    return c
end

-- Main Panel (draggable when open)
local panel = Instance.new("Frame")
panel.Name = "FlyPanel"
panel.AnchorPoint = Vector2.new(0.5, 1)
panel.Position = lastPanelPos
panel.Size = UDim2.fromOffset(220, 160)
panel.BackgroundColor3 = COLOR_BG
panel.BorderSizePixel = 0
panel.Parent = screenGui
corner(panel, 10)

local stroke = Instance.new("UIStroke")
stroke.Thickness = 1
stroke.Color = Color3.fromRGB(60,65,70)
stroke.Transparency = 0.2
stroke.Parent = panel

-- Title bar (as drag handle)
local titleBar = Instance.new("Frame")
titleBar.Name = "TitleBar"
titleBar.BackgroundTransparency = 0.2
titleBar.BackgroundColor3 = Color3.fromRGB(30,33,38)
titleBar.BorderSizePixel = 0
titleBar.Size = UDim2.new(1, 0, 0, 30)
titleBar.Parent = panel

local titleLabel = Instance.new("TextLabel")
titleLabel.BackgroundTransparency = 1
titleLabel.Font = Enum.Font.GothamMedium
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.TextColor3 = COLOR_TEXT
titleLabel.TextSize = 14
titleLabel.Text = "Mobile Fly"
titleLabel.Size = UDim2.new(1, -40, 1, 0)
titleLabel.Position = UDim2.new(0, 10, 0, 0)
titleLabel.Parent = titleBar

-- Collapse (-) button
local collapseBtn = Instance.new("TextButton")
collapseBtn.Name = "Collapse"
collapseBtn.Size = UDim2.fromOffset(24, 24)
collapseBtn.Position = UDim2.new(1, -28, 0.5, -12)
collapseBtn.Text = "-"
collapseBtn.AutoButtonColor = true
collapseBtn.BackgroundColor3 = Color3.fromRGB(50,54,60)
collapseBtn.TextColor3 = COLOR_TEXT
collapseBtn.Font = Enum.Font.GothamBold
collapseBtn.TextSize = 16
collapseBtn.Parent = titleBar
corner(collapseBtn, 6)

-- Toggle Fly button
local toggleBtn = Instance.new("TextButton")
toggleBtn.Name = "ToggleFly"
toggleBtn.Size = UDim2.new(1, -16, 0, 42)
toggleBtn.Position = UDim2.new(0, 8, 0, 40)
toggleBtn.BackgroundColor3 = COLOR_PRIMARY
toggleBtn.TextColor3 = COLOR_TEXT
toggleBtn.TextSize = 18
toggleBtn.Font = Enum.Font.GothamBold
toggleBtn.AutoButtonColor = true
toggleBtn.Text = "Enable Fly"
toggleBtn.Parent = panel
corner(toggleBtn, 8)

-- Up / Down buttons (press-and-hold friendly for mobile)
local upBtn = Instance.new("TextButton")
upBtn.Name = "Up"
upBtn.Size = UDim2.new(0.5, -12, 0, 40)
upBtn.Position = UDim2.new(0, 8, 0, 92)
upBtn.BackgroundColor3 = COLOR_ACCENT_GO
upBtn.Text = "↑ Up"
upBtn.TextColor3 = COLOR_TEXT
upBtn.TextSize = 16
upBtn.Font = Enum.Font.GothamMedium
upBtn.Parent = panel
corner(upBtn, 8)

local downBtn = Instance.new("TextButton")
downBtn.Name = "Down"
downBtn.Size = UDim2.new(0.5, -12, 0, 40)
downBtn.Position = UDim2.new(0.5, 4, 0, 92)
downBtn.BackgroundColor3 = COLOR_ACCENT_STOP
downBtn.Text = "↓ Down"
downBtn.TextColor3 = COLOR_TEXT
downBtn.TextSize = 16
downBtn.Font = Enum.Font.GothamMedium
downBtn.Parent = panel
corner(downBtn, 8)

-- Collapsed "+" button (not draggable)
local collapsedBtn = Instance.new("TextButton")
collapsedBtn.Name = "Collapsed"
collapsedBtn.Size = UDim2.fromOffset(46, 46)
collapsedBtn.AnchorPoint = Vector2.new(0.5, 1)
collapsedBtn.Position = panel.Position
collapsedBtn.BackgroundColor3 = COLOR_PRIMARY
collapsedBtn.Text = "+"
collapsedBtn.TextColor3 = COLOR_TEXT
collapsedBtn.TextSize = 22
collapsedBtn.Font = Enum.Font.GothamBold
collapsedBtn.Visible = false
collapsedBtn.Parent = screenGui
corner(collapsedBtn, 12)

-- Panel open/close logic
local function setPanelOpen(open)
    panelOpen = open
    panel.Visible = open
    collapsedBtn.Visible = not open
    collapseBtn.Text = open and "-" or "+"
    if open then
        -- snap panel to where the + was
        panel.Position = collapsedBtn.Position
    else
        -- remember last open position for when we reopen
        lastPanelPos = panel.Position
        collapsedBtn.Position = lastPanelPos
    end
end

collapseBtn.MouseButton1Click:Connect(function()
    setPanelOpen(false)
end)

collapsedBtn.MouseButton1Click:Connect(function()
    setPanelOpen(true)
end)

-- Dragging (only when open; use the titleBar as the handle)
local dragging = false
local dragStart, startPos
titleBar.InputBegan:Connect(function(input)
    if not panelOpen then return end
    if input.UserInputType == Enum.UserInputType.MouseButton1
        or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = panel.Position
        local conn
        conn = input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
                if conn then conn:Disconnect() end
            end
        end)
    end
end)

titleBar.InputChanged:Connect(function(input)
    if not dragging then return end
    if input.UserInputType == Enum.UserInputType.MouseMovement
        or input.UserInputType == Enum.UserInputType.Touch then
        local delta = input.Position - dragStart
        panel.Position = UDim2.new(
            startPos.X.Scale, startPos.X.Offset + delta.X,
            startPos.Y.Scale, startPos.Y.Offset + delta.Y
        )
        lastPanelPos = panel.Position
    end
end)

-- Fly mechanics (modern constraints)
local rootAttachment
local alignOrientation
local linearVelocity
local flyConn

-- Control acquisition (mobile-friendly; uses PlayerModule thumbstick)
local controls
local function getMoveVector()
    if controls then
        return controls:GetMoveVector()
    end
    local ps = player:FindFirstChild("PlayerScripts")
    local pm = ps and ps:FindFirstChild("PlayerModule")
    if pm then
        local module = require(pm)
        controls = module:GetControls()
        return controls:GetMoveVector()
    end
    return Vector3.zero
end

local function cleanFly()
    if flyConn then flyConn:Disconnect() flyConn = nil end
    if alignOrientation then alignOrientation:Destroy() alignOrientation = nil end
    if linearVelocity then linearVelocity:Destroy() linearVelocity = nil end
    if rootAttachment then rootAttachment:Destroy() rootAttachment = nil end
end

local function startFlying()
    if flying then return end
    flying = true
    toggleBtn.Text = "Disable Fly"
    toggleBtn.BackgroundColor3 = COLOR_ACCENT_STOP

    -- build attachments and constraints
    rootAttachment = Instance.new("Attachment")
    rootAttachment.Name = "FlyAttachment"
    rootAttachment.Parent = humanoidRootPart

    alignOrientation = Instance.new("AlignOrientation")
    alignOrientation.Name = "FlyAlign"
    alignOrientation.Attachment0 = rootAttachment
    alignOrientation.Mode = Enum.OrientationAlignmentMode.OneAttachment
    alignOrientation.Responsiveness = 60
    alignOrientation.MaxTorque = math.huge
    alignOrientation.Parent = humanoidRootPart

    linearVelocity = Instance.new("LinearVelocity")
    linearVelocity.Name = "FlyVelocity"
    linearVelocity.Attachment0 = rootAttachment
    linearVelocity.MaxForce = math.huge
    linearVelocity.VectorVelocity = Vector3.zero
    linearVelocity.RelativeTo = Enum.ActuatorRelativeTo.World
    linearVelocity.Parent = humanoidRootPart

    -- smooth camera-facing orient; maintain mobile thumbstick intention
    flyConn = RunService.RenderStepped:Connect(function(dt)
        if not flying then return end
        local cam = workspace.CurrentCamera
        local camCF = cam and cam.CFrame or humanoidRootPart.CFrame

        -- planar forward/right aligned to camera yaw
        local look = camCF.LookVector
        local right = camCF.RightVector
        local flatLook = Vector3.new(look.X, 0, look.Z)
        local flatRight = Vector3.new(right.X, 0, right.Z)
        if flatLook.Magnitude > 1e-3 then flatLook = flatLook.Unit end
        if flatRight.Magnitude > 1e-3 then flatRight = flatRight.Unit end

        local mv = getMoveVector() -- uses PlayerModule (works great on mobile)
        local planar = (flatRight * mv.X + flatLook * mv.Z)
        if planar.Magnitude > 1 then planar = planar.Unit end

        local vy = ascendHeld and verticalSpeed or (descendHeld and -verticalSpeed or 0)
        local desired = planar * speed + Vector3.new(0, vy, 0)

        linearVelocity.VectorVelocity = desired

        -- face travel direction if moving, else face camera forward
        local faceDir = planar.Magnitude > 0.01 and planar or flatLook
        if faceDir.Magnitude > 1e-3 then
            alignOrientation.CFrame = CFrame.lookAt(humanoidRootPart.Position, humanoidRootPart.Position + faceDir)
        end

        -- keep character from fighting the constraints
        humanoid.AutoRotate = false
        if flying and humanoid:GetState() ~= Enum.HumanoidStateType.Freefall then
            humanoid:ChangeState(Enum.HumanoidStateType.Freefall)
        end
    end)
end

local function stopFlying()
    if not flying then return end
    flying = false
    toggleBtn.Text = "Enable Fly"
    toggleBtn.BackgroundColor3 = COLOR_PRIMARY
    cleanFly()
    humanoid.AutoRotate = true
end

-- Button bindings (press & hold for mobile)
local function bindHold(btn, onDown, onUp)
    btn.MouseButton1Down:Connect(onDown)
    btn.MouseButton1Up:Connect(onUp)
    btn.TouchLongPress:Connect(function(_, state)
        if state == Enum.LongPressState.Begin then onDown()
        elseif state == Enum.LongPressState.End then onUp() end
    end)
    btn.TouchTap:Connect(function() -- single tap toggles too for accessibility
        onDown(); task.delay(0.12, onUp)
    end)
end

toggleBtn.MouseButton1Click:Connect(function()
    if flying then stopFlying() else startFlying() end
end)

bindHold(upBtn, function() ascendHeld = true end, function() ascendHeld = false end)
bindHold(downBtn, function() descendHeld = true end, function() descendHeld = false end)

-- Character respawn resilience
player.CharacterAdded:Connect(function(newChar)
    character = newChar
    humanoidRootPart = newChar:WaitForChild("HumanoidRootPart")
    humanoid = newChar:WaitForChild("Humanoid")
    if flying then
        cleanFly()
        -- slight delay to allow physics settle
        task.wait(0.15)
        startFlying()
    end
end)

-- Expose simple global for quick executor toggles (optional)
_G = rawget(getfenv() or _G, "_G") or _G
_G.MobileFly = {
    Toggle = function() if flying then stopFlying() else startFlying() end end,
    Start = startFlying,
    Stop = stopFlying,
    IsFlying = function() return flying end,
    SetSpeed = function(v) speed = math.clamp(tonumber(v) or speed, 10, 300) end,
    SetVertical = function(v) verticalSpeed = math.clamp(tonumber(v) or verticalSpeed, 5, 300) end,
    OpenUI = function() setPanelOpen(true) end,
    CloseUI = function() setPanelOpen(false) end,
}

-- Start in a safe default (UI open, not flying)
setPanelOpen(true)
