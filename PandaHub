-- PandaFly v2 — runtime-only, compact, draggable, minimizable UI with robust asset handling (PC/Mobile)
-- Paste into a LocalScript (StarterPlayerScripts) or run client-side. No pre-placed objects required.

--// Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInput = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")
local ContentProvider = game:GetService("ContentProvider")

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera

--// UI root (idempotent)
local parentGui = player:FindFirstChildOfClass("PlayerGui") or game:GetService("CoreGui")
local old = parentGui:FindFirstChild("PandaFlyGUI")
if old then old:Destroy() end

local gui = Instance.new("ScreenGui")
gui.Name = "PandaFlyGUI"
gui.ResetOnSpawn = false
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
gui.DisplayOrder = 9e6
gui.IgnoreGuiInset = true
gui.Parent = parentGui

--// Assets (replace with your own if desired)
local PANDA = "rbxassetid://140281572489473" -- PandaHub logo
local PCIMG = "rbxassetid://75277585107743"  -- Laptop icon
local PHIMG = "rbxassetid://75163729493008"  -- Phone icon

-- Robust preloader (instances for reliability + timeout)
local function preloadImages(ids, timeout)
    local folder = Instance.new("Folder")
    folder.Name = "PreloadBin"
    folder.Parent = gui
    local images = {}
    for _,id in ipairs(ids) do
        local img = Instance.new("ImageLabel")
        img.Visible = false
        img.Image = id
        img.Size = UDim2.fromOffset(1,1)
        img.Parent = folder
        table.insert(images, img)
    end
    local ok = false
    local done = false
    task.spawn(function()
        ok = pcall(function()
            ContentProvider:PreloadAsync(images)
        end)
        done = true
    end)
    local t0 = os.clock()
    local limit = timeout or 6
    while not done and os.clock() - t0 < limit do
        task.wait(0.05)
    end
    folder:Destroy()
    return ok
end

preloadImages({PANDA, PCIMG, PHIMG}, 6)

--// Theme
local C_TOPBAR = Color3.fromRGB(40, 120, 30)
local C_BODY_A = Color3.fromRGB(0, 255, 0)
local C_BODY_B = Color3.fromRGB(255, 255, 0)
local C_BTN    = Color3.fromRGB(0, 140, 0)
local C_PANEL  = Color3.fromRGB(20, 20, 20)
local C_TEXT   = Color3.new(1,1,1)
local C_BLACK  = Color3.new(0,0,0)

--// Helpers
local function corner(p, r)
    local c = Instance.new("UICorner")
    c.CornerRadius = UDim.new(0, r or 10)
    c.Parent = p
end

local function stroke(p, t, c)
    local s = Instance.new("UIStroke")
    s.Color = c or C_BLACK
    s.Thickness = t or 1
    s.Parent = p
end

local function gradient(p, a, b, rot)
    local g = Instance.new("UIGradient")
    g.Color = ColorSequence.new(a or C_BODY_A, b or C_BODY_B)
    g.Rotation = rot or 90
    g.Parent = p
end

local function labelStyle(lbl)
    lbl.Font = Enum.Font.Bangers
    lbl.TextColor3 = C_TEXT
    lbl.TextStrokeColor3 = C_BLACK
    lbl.TextStrokeTransparency = 0
    lbl.TextScaled = true
    lbl.TextWrapped = true
end

local function buttonStyle(btn)
    btn.BackgroundColor3 = C_BTN
    btn.AutoButtonColor = true
    btn.Font = Enum.Font.Bangers
    btn.TextColor3 = C_TEXT
    btn.TextStrokeColor3 = C_BLACK
    btn.TextStrokeTransparency = 0
    btn.TextScaled = true
    corner(btn, 8)
    stroke(btn, 1)
end

local function makePanelDraggable(panel, dragHandle)
    local dragging = false
    local dragStart, startPos
    dragHandle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = panel.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    dragHandle.InputChanged:Connect(function(input)
        if not dragging then return end
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            local delta = input.Position - dragStart
            panel.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
end

--// Minimizer
local function spawnMini(onRestore)
    local mini = Instance.new("Frame")
    mini.Name = "MiniPanda"
    mini.Size = UDim2.fromOffset(52,52)
    mini.Position = UDim2.new(0.5, -26, 0.65, -26)
    mini.BackgroundColor3 = C_TOPBAR
    mini.Active = true
    mini.Parent = gui
    corner(mini, 12)
    stroke(mini, 1)

    local img = Instance.new("ImageLabel")
    img.BackgroundTransparency = 1
    img.Image = PANDA
    img.Size = UDim2.fromScale(1,1)
    img.Parent = mini

    makePanelDraggable(mini, mini)

    local moved = 0
    local pressed = false
    mini.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            pressed = true
            moved = 0
        end
    end)
    mini.InputChanged:Connect(function(input)
        if pressed and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            moved += 1
        end
    end)
    mini.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            local wasDrag = moved > 2
            pressed = false
            if not wasDrag then
                mini:Destroy()
                onRestore()
            end
        end
    end)
end

--// Flight state
local flyConn, animConn, deathConn
local kbConns = {}
local flying = false
local mode = "none" -- "pc" or "phone"
local speed = 48
local minSpeed, maxSpeed = 8, 250

-- Physics attachments
local rootAtt, align, linVel, antiGrav

local function charHumanoid()
    local char = player.Character or player.CharacterAdded:Wait()
    return char, char:FindFirstChildOfClass("Humanoid")
end

local function stopAnimations(humanoid)
    for _,track in ipairs(humanoid:GetPlayingAnimationTracks()) do
        track:Stop(0.1)
    end
end

local function cleanFlight()
    if flyConn then flyConn:Disconnect() flyConn = nil end
    if animConn then animConn:Disconnect() animConn = nil end
    if align then align:Destroy() align = nil end
    if linVel then linVel:Destroy() linVel = nil end
    if antiGrav then antiGrav:Destroy() antiGrav = nil end
    if rootAtt then rootAtt:Destroy() rootAtt = nil end
    local _, hum = charHumanoid()
    if hum then hum.AutoRotate = true end
end

local function setupFlight()
    cleanFlight()
    local char, hum = charHumanoid()
    local root = char:FindFirstChild("HumanoidRootPart")
    if not root or not hum then return end

    hum.AutoRotate = false

    rootAtt = Instance.new("Attachment")
    rootAtt.Name = "PandaFly_Attachment"
    rootAtt.Parent = root

    align = Instance.new("AlignOrientation")
    align.Mode = Enum.OrientationAlignmentMode.OneAttachment
    align.Attachment0 = rootAtt
    align.Responsiveness = 200
    align.MaxTorque = math.huge
    align.Parent = root

    linVel = Instance.new("LinearVelocity")
    linVel.Attachment0 = rootAtt
    linVel.MaxForce = math.huge
    linVel.RelativeTo = Enum.ActuatorRelativeTo.World
    linVel.Parent = root

    antiGrav = Instance.new("VectorForce")
    antiGrav.Force = Vector3.new(0, workspace.Gravity * (hum:GetMass() or 100), 0)
    antiGrav.RelativeTo = Enum.ActuatorRelativeTo.World
    antiGrav.Attachment0 = rootAtt
    antiGrav.Parent = root

    -- stop character animations while flying
    animConn = hum.AnimationPlayed:Connect(function(track)
        if flying then
            task.defer(function() track:Stop(0.05) end)
        end
    end)
end

-- Mobile movement via PlayerModule when available; fallback to MoveDirection projection
local function getMoveVectorMobile()
    local v2 = Vector2.zero
    local ps = player:FindFirstChild("PlayerScripts")
    local pm = ps and ps:FindFirstChild("PlayerModule")
    if pm then
        local ok, controls = pcall(function() return require(pm):GetControls() end)
        if ok and controls and controls.GetMoveVector then
            local v = controls:GetMoveVector() -- Vector3
            return Vector2.new(v.X, -v.Z) -- x = strafe, y = forward
        end
    end
    local _, hum = charHumanoid()
    if hum then
        local dir = hum.MoveDirection
        local f = dir:Dot(camera.CFrame.LookVector)
        local s = dir:Dot(camera.CFrame.RightVector)
        v2 = Vector2.new(s, f)
    end
    return v2
end

-- Keyboard state for PC
local key = {W=false,A=false,S=false,D=false,Shift=false}
local function unbindPCKeys()
    for _,conn in ipairs(kbConns) do conn:Disconnect() end
    kbConns = {}
end
local function bindPCKeys(onToggle)
    unbindPCKeys()
    table.insert(kbConns, UserInput.InputBegan:Connect(function(inp, gp)
        if gp then return end
        if UserInput:GetFocusedTextBox() then return end
        if inp.KeyCode == Enum.KeyCode.W then key.W = true end
        if inp.KeyCode == Enum.KeyCode.A then key.A = true end
        if inp.KeyCode == Enum.KeyCode.S then key.S = true end
        if inp.KeyCode == Enum.KeyCode.D then key.D = true end
        if inp.KeyCode == Enum.KeyCode.LeftShift then key.Shift = true end
        if inp.KeyCode == Enum.KeyCode.E then if onToggle then onToggle() end end
    end))
    table.insert(kbConns, UserInput.InputEnded:Connect(function(inp)
        if inp.KeyCode == Enum.KeyCode.W then key.W = false end
        if inp.KeyCode == Enum.KeyCode.A then key.A = false end
        if inp.KeyCode == Enum.KeyCode.S then key.S = false end
        if inp.KeyCode == Enum.KeyCode.D then key.D = false end
        if inp.KeyCode == Enum.KeyCode.LeftShift then key.Shift = false end
    end))
end

-- Compute desired movement
local function desiredMoveVector()
    if mode == "pc" then
        local x = (key.D and 1 or 0) - (key.A and 1 or 0)
        local y = (key.W and 1 or 0) - (key.S and 1 or 0)
        return Vector2.new(x, y)
    else
        return getMoveVectorMobile()
    end
end

--// UI Construction
local safePad = 10
local panel = Instance.new("Frame")
panel.Name = "PandaPanel"
panel.Size = UDim2.new(0, 320, 0, 210)
panel.Position = UDim2.new(1, -(320 + safePad), 0, safePad)
panel.BackgroundColor3 = C_PANEL
panel.Active = true
panel.Parent = gui
corner(panel, 12)
stroke(panel, 1)

gradient(panel, C_BODY_A, C_BODY_B, 90)

-- top bar
local top = Instance.new("Frame")
top.Name = "TopBar"
top.Size = UDim2.new(1, 0, 0, 34)
top.BackgroundColor3 = C_TOPBAR
top.Parent = panel
corner(top, 12)
stroke(top, 1)

local topPad = Instance.new("UIPadding")
topPad.PaddingLeft = UDim.new(0, 8)
topPad.PaddingRight = UDim.new(0, 8)
topPad.Parent = top

local icon = Instance.new("ImageLabel")
icon.BackgroundTransparency = 1
icon.Image = PANDA
icon.Size = UDim2.fromOffset(24,24)
icon.Position = UDim2.new(0, 4, 0.5, -12)
icon.Parent = top

local title = Instance.new("TextLabel")
title.BackgroundTransparency = 1
title.Text = "PandaFly v2"
title.AnchorPoint = Vector2.new(0, 0.5)
title.Position = UDim2.new(0, 36, 0.5, 0)
title.Size = UDim2.new(1, -100, 1, -8)
labelStyle(title)
title.Parent = top

local btnRow = Instance.new("Frame")
btnRow.BackgroundTransparency = 1
btnRow.Size = UDim2.new(0, 88, 1, 0)
btnRow.AnchorPoint = Vector2.new(1,0)
btnRow.Position = UDim2.new(1, 0, 0, 0)
btnRow.Parent = top

local uiListTop = Instance.new("UIListLayout")
uiListTop.FillDirection = Enum.FillDirection.Horizontal
uiListTop.HorizontalAlignment = Enum.HorizontalAlignment.Right
uiListTop.SortOrder = Enum.SortOrder.LayoutOrder
uiListTop.Padding = UDim.new(0, 6)
uiListTop.Parent = btnRow

local minimize = Instance.new("TextButton")
minimize.Text = "—"
minimize.Size = UDim2.fromOffset(34,24)
buttonStyle(minimize)
minimize.Parent = btnRow

local closeBtn = Instance.new("TextButton")
closeBtn.Text = "x"
closeBtn.Size = UDim2.fromOffset(34,24)
buttonStyle(closeBtn)
closeBtn.Parent = btnRow

makePanelDraggable(panel, top)

-- body container
local body = Instance.new("Frame")
body.BackgroundTransparency = 1
body.Size = UDim2.new(1, -12, 1, -(34 + 12))
body.Position = UDim2.new(0, 6, 0, 34 + 6)
body.Parent = panel

local uiList = Instance.new("UIListLayout")
uiList.Padding = UDim.new(0, 8)
uiList.HorizontalAlignment = Enum.HorizontalAlignment.Center
uiList.SortOrder = Enum.SortOrder.LayoutOrder
uiList.Parent = body

-- mode row
local modeRow = Instance.new("Frame")
modeRow.BackgroundTransparency = 1
modeRow.Size = UDim2.new(1, -12, 0, 48)
modeRow.Parent = body

local modeList = Instance.new("UIListLayout")
modeList.FillDirection = Enum.FillDirection.Horizontal
modeList.Padding = UDim.new(0, 8)
modeList.HorizontalAlignment = Enum.HorizontalAlignment.Center
modeList.Parent = modeRow

local function makeModeButton(txt, img)
    local f = Instance.new("Frame")
    f.BackgroundTransparency = 1
    f.Size = UDim2.new(0, 150, 1, 0)
    local b = Instance.new("TextButton")
    b.Size = UDim2.new(1, 0, 1, 0)
    b.Text = txt
    buttonStyle(b)
    b.Parent = f
    local i = Instance.new("ImageLabel")
    i.BackgroundTransparency = 1
    i.Image = img
    i.Size = UDim2.fromOffset(20,20)
    i.Position = UDim2.new(0, 8, 0.5, -10)
    i.Parent = b
    return f, b
end

local pcFrame, pcBtn = makeModeButton("PC", PCIMG)
pcFrame.Parent = modeRow
local phFrame, phBtn = makeModeButton("Mobile", PHIMG)
phFrame.Parent = modeRow

-- speed row
local speedRow = Instance.new("Frame")
speedRow.BackgroundTransparency = 1
speedRow.Size = UDim2.new(1, -12, 0, 48)
speedRow.Parent = body

local speedList = Instance.new("UIListLayout")
speedList.FillDirection = Enum.FillDirection.Horizontal
speedList.Padding = UDim.new(0, 8)
speedList.HorizontalAlignment = Enum.HorizontalAlignment.Center
speedList.Parent = speedRow

local speedLabel = Instance.new("TextLabel")
speedLabel.BackgroundTransparency = 1
speedLabel.Size = UDim2.new(0, 120, 1, 0)
speedLabel.Text = "Speed"
labelStyle(speedLabel)
speedLabel.Parent = speedRow

local speedBox = Instance.new("TextBox")
speedBox.Size = UDim2.new(0, 80, 1, 0)
speedBox.Text = tostring(speed)
speedBox.ClearTextOnFocus = false
speedBox.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
labelStyle(speedBox)
corner(speedBox, 8)
stroke(speedBox, 1)
speedBox.Parent = speedRow

local speedMinus = Instance.new("TextButton")
speedMinus.Text = "−"
speedMinus.Size = UDim2.fromOffset(40, 36)
buttonStyle(speedMinus)
speedMinus.Parent = speedRow

local speedPlus = Instance.new("TextButton")
speedPlus.Text = "+"
speedPlus.Size = UDim2.fromOffset(40, 36)
buttonStyle(speedPlus)
speedPlus.Parent = speedRow

-- status row
local statusRow = Instance.new("Frame")
statusRow.BackgroundTransparency = 1
statusRow.Size = UDim2.new(1, -12, 0, 30)
statusRow.Parent = body

local statusText = Instance.new("TextLabel")
statusText.BackgroundTransparency = 1
statusText.Size = UDim2.new(1, 0, 1, 0)
statusText.Text = "Select mode to enable controls"
labelStyle(statusText)
statusText.Parent = statusRow

-- control row
local controlRow = Instance.new("Frame")
controlRow.BackgroundTransparency = 1
controlRow.Size = UDim2.new(1, -12, 0, 48)
controlRow.Parent = body

local ctrlList = Instance.new("UIListLayout")
ctrlList.FillDirection = Enum.FillDirection.Horizontal
ctrlList.Padding = UDim.new(0, 8)
ctrlList.HorizontalAlignment = Enum.HorizontalAlignment.Center
ctrlList.Parent = controlRow

local startBtn = Instance.new("TextButton")
startBtn.Text = "Start"
startBtn.Size = UDim2.new(0, 150, 1, 0)
buttonStyle(startBtn)
startBtn.AutoButtonColor = true
startBtn.Parent = controlRow

local stopBtn = Instance.new("TextButton")
stopBtn.Text = "Stop"
stopBtn.Size = UDim2.new(0, 150, 1, 0)
buttonStyle(stopBtn)
stopBtn.AutoButtonColor = true
stopBtn.Parent = controlRow
stopBtn.Visible = false

-- hint row
local hintRow = Instance.new("Frame")
hintRow.BackgroundTransparency = 1
hintRow.Size = UDim2.new(1, -12, 0, 24)
hintRow.Parent = body

local hintText = Instance.new("TextLabel")
hintText.BackgroundTransparency = 1
hintText.Size = UDim2.new(1, 0, 1, 0)
hintText.Text = ""
labelStyle(hintText)
hintText.Parent = hintRow

-- visibility helpers
local function setMode(newMode)
    mode = newMode
    if mode == "pc" then
        bindPCKeys(function()
            if not flying then
                flying = true
                setupFlight()
            else
                flying = false
                cleanFlight()
            end
            startBtn.Visible = not flying
            stopBtn.Visible = flying
            statusText.Text = flying and "Flying (PC) — WASD, E to toggle" or "Ready (PC) — press Start or E"
        end)
        hintText.Text = "WASD to move. Press E to toggle. Drag panel by top bar."
        statusText.Text = "PC selected — press Start or E"
    else
        unbindPCKeys()
        hintText.Text = "Virtual joystick to move. Drag panel by top bar."
        statusText.Text = "Mobile selected — press Start"
    end
end

-- auto-detect default
if UserInput.KeyboardEnabled and not UserInput.TouchEnabled then
    setMode("pc")
else
    setMode("phone")
end

-- UI logic
local function clampSpeed(v)
    v = math.clamp(math.floor(tonumber(v) or speed), minSpeed, maxSpeed)
    return v
end

local function applySpeed(v)
    speed = clampSpeed(v)
    speedBox.Text = tostring(speed)
end

speedBox.FocusLost:Connect(function(enterPressed)
    applySpeed(speedBox.Text)
end)

speedMinus.MouseButton1Click:Connect(function()
    applySpeed(speed - 4)
end)

speedPlus.MouseButton1Click:Connect(function()
    applySpeed(speed + 4)
end)

pcBtn.MouseButton1Click:Connect(function() setMode("pc") end)
phBtn.MouseButton1Click:Connect(function() setMode("phone") end)

local function uiSetFlying(state)
    flying = state
    if flying then
        setupFlight()
        startBtn.Visible = false
        stopBtn.Visible = true
        statusText.Text = mode == "pc" and "Flying (PC) — WASD, E to toggle" or "Flying (Mobile)"
    else
        cleanFlight()
        startBtn.Visible = true
        stopBtn.Visible = false
        statusText.Text = mode == "pc" and "Ready (PC) — press Start or E" or "Ready (Mobile) — press Start"
    end
end

startBtn.MouseButton1Click:Connect(function()
    uiSetFlying(true)
end)
stopBtn.MouseButton1Click:Connect(function()
    uiSetFlying(false)
end)

minimize.MouseButton1Click:Connect(function()
    panel.Visible = false
    spawnMini(function()
        panel.Visible = true
    end)
end)

closeBtn.MouseButton1Click:Connect(function()
    uiSetFlying(false)
    gui:Destroy()
end)

-- Keep panel onscreen on resize
local function keepOnScreen()
    local vp = camera.ViewportSize
    local x = math.clamp(panel.AbsolutePosition.X, 4, vp.X - panel.AbsoluteSize.X - 4)
    local y = math.clamp(panel.AbsolutePosition.Y, 4, vp.Y - panel.AbsoluteSize.Y - 4)
    panel.Position = UDim2.fromOffset(x, y)
end
camera:GetPropertyChangedSignal("ViewportSize"):Connect(keepOnScreen)

-- Flight loop
local function step(dt)
    if not flying then return end
    local char, hum = charHumanoid()
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if not (root and hum and align and linVel and rootAtt) then return end

    local mv2 = desiredMoveVector()
    -- Optional: discourage backward flight on mobile for comfort
    if mode == "phone" and mv2.Y < 0 then
        mv2 = Vector2.new(mv2.X, 0)
    end

    local dir = (camera.CFrame.LookVector * mv2.Y + camera.CFrame.RightVector * mv2.X)
    if dir.Magnitude > 0.001 then
        dir = dir.Unit
    else
        dir = Vector3.zero
    end

    local spd = speed * (mode == "pc" and (key.Shift and 1.35 or 1.0) or 1.0)
    linVel.VectorVelocity = dir * spd

    -- face velocity direction when moving; face camera when idle
    local faceDir = dir.Magnitude > 0 and dir or camera.CFrame.LookVector
    local lookCFrame = CFrame.lookAt(root.Position, root.Position + faceDir, Vector3.new(0,1,0))
    align.CFrame = lookCFrame
end

flyConn = RunService.RenderStepped:Connect(step)

-- Cleanup on death/respawn
player.CharacterAdded:Connect(function(char)
    if deathConn then deathConn:Disconnect() deathConn = nil end
    task.wait(0.2)
    local hum = char:FindFirstChildOfClass("Humanoid") or char:WaitForChild("Humanoid", 5)
    if hum then
        deathConn = hum.Died:Connect(function()
            uiSetFlying(false)
        end)
    end
end)

-- Initial death hook if already spawned
task.spawn(function()
    local char, hum = charHumanoid()
    if hum then
        if deathConn then deathConn:Disconnect() end
        deathConn = hum.Died:Connect(function()
            uiSetFlying(false)
        end)
    end
end)

-- Make sure labels are always visible and not clipped
local function recurseFixClipping(inst)
    if inst:IsA("GuiObject") then
        inst.ClipsDescendants = false
        inst.ZIndex = inst.ZIndex -- touch to ensure layout consistency
    end
    for _,child in ipairs(inst:GetChildren()) do
        recurseFixClipping(child)
    end
end
recurseFixClipping(panel)

-- Done: UI is runtime-built, scale-aware, text autoscaled, assets preloaded, and flight is client-only.
