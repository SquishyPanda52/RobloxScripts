--[[
When you’re creating a mechanic from scratch with code, what really matters is that the code runs on the client, not where it lives in the Explorer. Whether the local script shows up under workspace, PlayerGui, or nowhere at all, as long as it has access to:

game.Players.LocalPlayer

RunService.RenderStepped (or Heartbeat)

The player’s HumanoidRootPart

Quick Tips
To avoid any parent-dependent bugs, use absolute service calls:

If we ever need the code to act like a true LocalScript (e.g., GUI in PlayerGui), you can forcibly reparent:
script.Parent = player:WaitForChild("PlayerGui")

For maximum stealth and reliability, combine with auto-reparent logic:

-- detect where you are, then optionally move

if not script:IsDescendantOf(game:GetService("StarterPlayer").StarterPlayerScripts) then
    script.Parent = game:GetService("StarterPlayer").StarterPlayerScripts
end

Other Frequent  Spots
Memory-Only (No Visible Parent) Some code execute purely in memory. You won’t see the script object anywhere in the Explorer.

CoreGui UI-focused code often lands here

ReplicatedFirst / ReplicatedStorage Less common, but occasionally used by coders that want their code to replicate to clients or persist beyond a single session.

StarterPlayerScripts / PlayerScripts  can reparent here to run code as a true LocalScript

Try to use Memory only the most, if necessary use the other mechanics

but try to do StarterPlayerScripts / PlayersScripts the LEAST.
]]

-- =================================================================================================
-- Local fly system (UI fully generated in code, mobile-first, draggable only when open)
-- Memory-first execution: we do NOT reparent unless absolutely necessary.
-- =================================================================================================

-- Services (absolute calls to avoid parent-dependent bugs)
local Players            = game:GetService("Players")
local RunService         = game:GetService("RunService")
local UserInputService   = game:GetService("UserInputService")
local GuiService         = game:GetService("GuiService")
local StarterPlayer      = game:GetService("StarterPlayer")

-- LocalPlayer and character plumbing (robust across respawns)
local player = Players.LocalPlayer
while not player do task.wait() player = Players.LocalPlayer end

local function getCharacter()
    local char = player.Character or player.CharacterAdded:Wait()
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    return char, hum, hrp
end

local character, humanoid, root = getCharacter()

player.CharacterAdded:Connect(function()
    character, humanoid, root = getCharacter()
    -- If we were flying at respawn, restore flight safely
    if _G.__FlyState and _G.__FlyState.flying then
        task.defer(function()
            _G.__FlyState.restoreAfterRespawn = true
        end)
    end
end)

-- Optional stealth reparenting (disabled by default to prefer memory-only)
--[[
if not script:IsDescendantOf(StarterPlayer.StarterPlayerScripts) then
    script.Parent = StarterPlayer.StarterPlayerScripts
end
]]

-- =================================================================================================
-- State
-- =================================================================================================
_G.__FlyState = _G.__FlyState or {}
local flying = false
local panelOpen = true
local ascendHeld = false
local descendHeld = false

-- Tunables (mobile-friendly defaults)
local horizontalSpeed = 72      -- studs/sec
local verticalSpeed   = 48      -- studs/sec
local turnResponsiveness = 55   -- AlignOrientation responsiveness
local uiPadding = 12

-- Connections for cleanup
local renderConn: RBXScriptConnection? = nil
local inputConns: {RBXScriptConnection} = {}

-- Flight constraints
local rootAttachment: Attachment? = nil
local alignOrientation: AlignOrientation? = nil
local linearVelocity: LinearVelocity? = nil

-- =================================================================================================
-- UI (all generated in code)
-- =================================================================================================
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "Fly_UI"
screenGui.IgnoreGuiInset = true
screenGui.ResetOnSpawn = false
screenGui.DisplayOrder = 1000
screenGui.Parent = player:WaitForChild("PlayerGui")

-- Helper: common UI parts
local function addCorner(inst, r)
    local c = Instance.new("UICorner")
    c.CornerRadius = UDim.new(0, r or 8)
    c.Parent = inst
    return c
end

local function addStroke(inst, thickness, color, transparency)
    local s = Instance.new("UIStroke")
    s.Thickness = thickness or 1.5
    s.Color = color or Color3.fromRGB(0,0,0)
    s.Transparency = transparency or 0.2
    s.Parent = inst
    return s
end

local function styleButton(btn, bg, txt, bold, rounded)
    btn.AutoButtonColor = true
    btn.BackgroundColor3 = bg
    btn.TextColor3 = txt or Color3.new(1,1,1)
    btn.Font = bold and Enum.Font.GothamBold or Enum.Font.Gotham
    btn.TextScaled = true
    btn.RichText = false
    btn.Active = true
    addCorner(btn, rounded and 10 or 6)
    addStroke(btn, 1.5, Color3.fromRGB(0,0,0), 0.4)
    local padding = Instance.new("UIPadding")
    padding.PaddingLeft = UDim.new(0, 8)
    padding.PaddingRight = UDim.new(0, 8)
    padding.Parent = btn
end

-- Main panel (draggable only when open)
local panel = Instance.new("Frame")
panel.Name = "FlyPanel"
panel.AnchorPoint = Vector2.new(0.5, 1)
panel.Size = UDim2.fromOffset(260, 170)
panel.Position = UDim2.new(0.5, 0, 1, -(150))
panel.BackgroundColor3 = Color3.fromRGB(24, 26, 30)
panel.Active = true
panel.Visible = true
addCorner(panel, 12)
addStroke(panel, 2, Color3.fromRGB(0,0,0), 0.25)
panel.Parent = screenGui

local layout = Instance.new("UIListLayout")
layout.FillDirection = Enum.FillDirection.Vertical
layout.SortOrder = Enum.SortOrder.LayoutOrder
layout.Padding = UDim.new(0, uiPadding)
layout.Parent = panel

local panelPad = Instance.new("UIPadding")
panelPad.PaddingTop = UDim.new(0, uiPadding)
panelPad.PaddingBottom = UDim.new(0, uiPadding)
panelPad.PaddingLeft = UDim.new(0, uiPadding)
panelPad.PaddingRight = UDim.new(0, uiPadding)
panelPad.Parent = panel

-- Header row
local header = Instance.new("Frame")
header.BackgroundTransparency = 1
header.Size = UDim2.new(1, 0, 0, 32)
header.LayoutOrder = 1
header.Parent = panel

local headerLayout = Instance.new("UIListLayout")
headerLayout.FillDirection = Enum.FillDirection.Horizontal
headerLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
headerLayout.VerticalAlignment = Enum.VerticalAlignment.Center
headerLayout.Padding = UDim.new(0, 8)
headerLayout.Parent = header

local title = Instance.new("TextLabel")
title.BackgroundTransparency = 1
title.Text = "Fly Controls"
title.Font = Enum.Font.GothamBold
title.TextScaled = true
title.TextColor3 = Color3.fromRGB(230, 235, 240)
title.Size = UDim2.new(1, -40, 1, 0)
title.LayoutOrder = 1
title.Parent = header

local collapseBtn = Instance.new("TextButton")
collapseBtn.Name = "Collapse"
collapseBtn.Size = UDim2.fromOffset(32, 32)
collapseBtn.LayoutOrder = 2
collapseBtn.Text = "-"
styleButton(collapseBtn, Color3.fromRGB(50, 55, 60), Color3.new(1,1,1), true, true)
collapseBtn.Parent = header

-- Toggle fly button
local toggleBtn = Instance.new("TextButton")
toggleBtn.Name = "ToggleFly"
toggleBtn.Size = UDim2.new(1, 0, 0, 52)
toggleBtn.LayoutOrder = 2
toggleBtn.Text = "Enable Fly"
styleButton(toggleBtn, Color3.fromRGB(0, 170, 255), Color3.new(1,1,1), true, true)
toggleBtn.Parent = panel

-- Up/Down row (press and hold for vertical motion)
local vertRow = Instance.new("Frame")
vertRow.BackgroundTransparency = 1
vertRow.Size = UDim2.new(1, 0, 0, 52)
vertRow.LayoutOrder = 3
vertRow.Parent = panel

local vertLayout = Instance.new("UIListLayout")
vertLayout.FillDirection = Enum.FillDirection.Horizontal
vertLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
vertLayout.VerticalAlignment = Enum.VerticalAlignment.Center
vertLayout.Padding = UDim.new(0, uiPadding)
vertLayout.Parent = vertRow

local upBtn = Instance.new("TextButton")
upBtn.Name = "Ascend"
upBtn.Size = UDim2.new(0.5, -uiPadding/2, 1, 0)
upBtn.Text = "↑ Up (hold)"
styleButton(upBtn, Color3.fromRGB(90, 190, 120), Color3.new(1,1,1), true, true)
upBtn.Parent = vertRow

local downBtn = Instance.new("TextButton")
downBtn.Name = "Descend"
downBtn.Size = UDim2.new(0.5, -uiPadding/2, 1, 0)
downBtn.Text = "↓ Down (hold)"
styleButton(downBtn, Color3.fromRGB(220, 110, 110), Color3.new(1,1,1), true, true)
downBtn.Parent = vertRow

-- Collapsed "+" button (NOT draggable; only opens the panel)
local collapsedBtn = Instance.new("TextButton")
collapsedBtn.Name = "OpenFlyPanel"
collapsedBtn.AnchorPoint = panel.AnchorPoint
collapsedBtn.Position = panel.Position
collapsedBtn.Size = UDim2.fromOffset(44, 44)
collapsedBtn.Text = "+"
styleButton(collapsedBtn, Color3.fromRGB(0, 170, 255), Color3.new(1,1,1), true, true)
collapsedBtn.Visible = false
collapsedBtn.Parent = screenGui

-- Keep collapsed button 'tethered' to panel's last position
local function syncCollapsedPosition()
    collapsedBtn.Position = panel.Position
    collapsedBtn.AnchorPoint = panel.AnchorPoint
end

-- Open/close handlers
local function setPanelOpen(open: boolean)
    panelOpen = open
    panel.Visible = open
    collapsedBtn.Visible = not open
    collapseBtn.Text = open and "-" or "+"
    syncCollapsedPosition()
end

collapseBtn.MouseButton1Click:Connect(function()
    setPanelOpen(false)
end)

collapsedBtn.MouseButton1Click:Connect(function()
    setPanelOpen(true)
end)

-- =================================================================================================
-- Draggable (only when open)
-- =================================================================================================
local dragging = false
local dragStart
local startPos

local function clampToViewport(pos: UDim2)
    local vp = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize or Vector2.new(1920, 1080)
    local frameSize = panel.AbsoluteSize
    local x = math.clamp(pos.X.Offset, 0, vp.X - frameSize.X)
    local y = math.clamp(pos.Y.Offset, 0, vp.Y - frameSize.Y)
    return UDim2.new(0, x, 0, y)
end

panel.InputBegan:Connect(function(input)
    if not panelOpen then return end
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = panel.Position
        -- end drag when input ends
        local endedConn
        endedConn = input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
                if endedConn then endedConn:Disconnect() end
            end
        end)
    end
end)

panel.InputChanged:Connect(function(input)
    if not panelOpen then return end
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        local delta = input.Position - dragStart
        local newPos = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        panel.Position = clampToViewport(newPos)
        syncCollapsedPosition()
    end
end)

-- =================================================================================================
-- Controls: movement vector (supports mobile thumbstick), plus ascend/descend via UI or keys
-- =================================================================================================
local controls
do
    -- Use PlayerModule controls if available for universal GetMoveVector (mobile & desktop)
    local ok, mod = pcall(function()
        return require(player:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule"))
    end)
    if ok and mod and mod:GetControls then
        controls = mod:GetControls()
    end
end

local function getPlanarMove()
    if controls and controls.GetMoveVector then
        return controls:GetMoveVector() -- X,Z plane in camera-relative terms
    end
    -- Fallback: WASD on desktop
    local move = Vector3.zero
    if UserInputService:IsKeyDown(Enum.KeyCode.W) then move = move + Vector3.new(0,0,1) end
    if UserInputService:IsKeyDown(Enum.KeyCode.S) then move = move - Vector3.new(0,0,1) end
    if UserInputService:IsKeyDown(Enum.KeyCode.D) then move = move + Vector3.new(1,0,0) end
    if UserInputService:IsKeyDown(Enum.KeyCode.A) then move = move - Vector3.new(1,0,0) end
    return Vector3.new(move.X, 0, move.Z)
end

-- Keyboard helpers for ascend/descend (desktop; mobile uses buttons)
table.insert(inputConns, UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if input.KeyCode == Enum.KeyCode.E then ascendHeld = true end
    if input.KeyCode == Enum.KeyCode.Q then descendHeld = true end
end))
table.insert(inputConns, UserInputService.InputEnded:Connect(function(input, gpe)
    if input.KeyCode == Enum.KeyCode.E then ascendHeld = false end
    if input.KeyCode == Enum.KeyCode.Q then descendHeld = false end
    -- Safety: release on any touch end
    if input.UserInputType == Enum.UserInputType.Touch then
        ascendHeld = false
        descendHeld = false
    end
end))

-- Mobile-friendly press-and-hold
local function bindHold(button: TextButton, setFlag: (boolean) -> ())
    button.MouseButton1Down:Connect(function() setFlag(true) end)
    button.MouseButton1Up:Connect(function() setFlag(false) end)
    -- Touch drag off safety
    button.TouchEnded:Connect(function() setFlag(false) end)
end
bindHold(upBtn, function(v) ascendHeld = v end)
bindHold(downBtn, function(v) descendHeld = v end)

-- =================================================================================================
-- Flight core
-- =================================================================================================
local function cleanupFlight()
    if renderConn then renderConn:Disconnect() renderConn = nil end
    if alignOrientation then alignOrientation:Destroy() alignOrientation = nil end
    if linearVelocity then linearVelocity:Destroy() linearVelocity = nil end
    if rootAttachment then rootAttachment:Destroy() rootAttachment = nil end
    if humanoid then
        humanoid.AutoRotate = true
        humanoid.PlatformStand = false
    end
end

local function startFlying()
    if flying then return end
    flying = true
    _G.__FlyState.flying = true
    toggleBtn.Text = "Disable Fly"

    -- Prepare constraints
    rootAttachment = Instance.new("Attachment")
    rootAttachment.Name = "FlyRootAttachment"
    rootAttachment.Parent = root

    alignOrientation = Instance.new("AlignOrientation")
    alignOrientation.Attachment0 = rootAttachment
    alignOrientation.Mode = Enum.OrientationAlignmentMode.OneAttachment
    alignOrientation.Responsiveness = turnResponsiveness
    alignOrientation.RigidityEnabled = false
    alignOrientation.Parent = root

    linearVelocity = Instance.new("LinearVelocity")
    linearVelocity.Attachment0 = rootAttachment
    linearVelocity.MaxForce = math.huge
    linearVelocity.RelativeTo = Enum.ActuatorRelativeTo.World
    linearVelocity.VectorVelocity = Vector3.zero
    linearVelocity.Parent = root

    -- Stabilize humanoid to avoid animation/controller fighting
    humanoid.AutoRotate = false
    humanoid.PlatformStand = true

    -- Render loop
    renderConn = RunService.RenderStepped:Connect(function()
        if not flying or not character or not root then return end

        local cam = workspace.CurrentCamera
        if not cam then return end

        -- Camera-relative planar axes
        local look = cam.CFrame.LookVector
        local right = cam.CFrame.RightVector
        local flatLook = Vector3.new(look.X, 0, look.Z)
        local flatRight = Vector3.new(right.X, 0, right.Z)
        if flatLook.Magnitude > 1e-3 then flatLook = flatLook.Unit end
        if flatRight.Magnitude > 1e-3 then flatRight = flatRight.Unit end

        local mv = getPlanarMove()
        local planar = (flatRight * mv.X + flatLook * mv.Z)
        if planar.Magnitude > 1 then planar = planar.Unit end

        local vy = (ascendHeld and verticalSpeed) or (descendHeld and -verticalSpeed) or 0
        local desired = Vector3.new(0, vy, 0) + planar * horizontalSpeed

        linearVelocity.VectorVelocity = desired

        local faceDir = planar.Magnitude > 0.1 and planar or flatLook
        if faceDir.Magnitude > 1e-3 then
            local targetCF = CFrame.lookAt(root.Position, root.Position + faceDir)
            alignOrientation.CFrame = targetCF
        end
    end)
end

local function stopFlying()
    if not flying then return end
    flying = false
    _G.__FlyState.flying = false
    toggleBtn.Text = "Enable Fly"
    cleanupFlight()
end

toggleBtn.MouseButton1Click:Connect(function()
    if flying then stopFlying() else startFlying() end
end)

-- Restore after respawn if we were flying
if _G.__FlyState.restoreAfterRespawn then
    _G.__FlyState.restoreAfterRespawn = nil
    startFlying()
end

-- Safety cleanup on script disable/destroy
script.AncestryChanged:Connect(function(_, parent)
    if not parent then
        stopFlying()
        for _, c in ipairs(inputConns) do c:Disconnect() end
    end
end)
