-------------------------------------------------------------------------------------------------------------------------------------------
-- Client-only, runtime UI, memory-first. Needs: LocalPlayer, RenderStepped, HumanoidRootPart. Absolute service calls, prints location.
-------------------------------------------------------------------------------------------------------------------------------------------
local Players=game:GetService("Players")
local RunService=game:GetService("RunService")
local UIS=game:GetService("UserInputService")
local player=Players.LocalPlayer
local character=player.Character or player.CharacterAdded:Wait()
local hrp=character:WaitForChild("HumanoidRootPart")
local humanoid=character:WaitForChild("Humanoid")
print("[MobileFly] script parent:", script.Parent and script.Parent:GetFullName() or "nil (memory-only)")

-- UI root
local guiName="MobileFlyUI"
local pg=player:WaitForChild("PlayerGui")
local old=pg:FindFirstChild(guiName); if old then old:Destroy() end
local gui=Instance.new("ScreenGui"); gui.Name=guiName; gui.ResetOnSpawn=false; gui.DisplayOrder=9999; gui.ZIndexBehavior=Enum.ZIndexBehavior.Sibling; gui.Parent=pg
print("[MobileFly] UI parent:", gui.Parent and gui.Parent:GetFullName() or "nil")

-- Theme
local C_PRIMARY=Color3.fromRGB(0,170,255)
local C_BG=Color3.fromRGB(20,22,26)
local C_TEXT=Color3.new(1,1,1)
local C_BAR=Color3.fromRGB(30,33,38)
local C_STOP=Color3.fromRGB(220,110,110)
local C_STROKE=Color3.fromRGB(60,65,70)

local function corner(p,r) local c=Instance.new("UICorner"); c.CornerRadius=UDim.new(0,r or 8); c.Parent=p; return c end
local function stroke(p,t,c,tr) local s=Instance.new("UIStroke"); s.Thickness=t or 1; s.Color=c or C_STROKE; s.Transparency=tr or 0.2; s.Parent=p; return s end

-- State
local flying=false
local panelOpen=true
local speed=70
local lastPanelPos=UDim2.new(0.5,-100,1,-120)
local controlMode="mobile" -- "mobile" or "keyboard"

-- Panel
local panel=Instance.new("Frame")
panel.Name="FlyPanel"; panel.AnchorPoint=Vector2.new(0.5,1); panel.Position=lastPanelPos; panel.Size=UDim2.fromOffset(240,120)
panel.BackgroundColor3=C_BG; panel.BorderSizePixel=0; panel.Parent=gui; corner(panel,10) stroke(panel,1)

local titleBar=Instance.new("Frame")
titleBar.Name="TitleBar"; titleBar.BackgroundColor3=C_BAR; titleBar.BackgroundTransparency=0.2; titleBar.BorderSizePixel=0; titleBar.Size=UDim2.new(1,0,0,30); titleBar.Parent=panel

local title=Instance.new("TextLabel")
title.BackgroundTransparency=1; title.Font=Enum.Font.GothamMedium; title.TextXAlignment=Enum.TextXAlignment.Left
title.TextColor3=C_TEXT; title.TextSize=14; title.Text="Mobile Fly"; title.Size=UDim2.new(1,-98,1,0); title.Position=UDim2.new(0,10,0,0); title.Parent=titleBar

local collapseBtn=Instance.new("TextButton")
collapseBtn.Size=UDim2.fromOffset(24,24); collapseBtn.Position=UDim2.new(1,-56,0.5,-12); collapseBtn.Text="-"; collapseBtn.AutoButtonColor=true
collapseBtn.BackgroundColor3=Color3.fromRGB(50,54,60); collapseBtn.TextColor3=C_TEXT; collapseBtn.Font=Enum.Font.GothamBold; collapseBtn.TextSize=16; collapseBtn.Parent=titleBar; corner(collapseBtn,6)

local closeBtn=Instance.new("TextButton")
closeBtn.Size=UDim2.fromOffset(24,24); closeBtn.Position=UDim2.new(1,-28,0.5,-12); closeBtn.Text="X"; closeBtn.AutoButtonColor=true
closeBtn.BackgroundColor3=Color3.fromRGB(70,40,40); closeBtn.TextColor3=C_TEXT; closeBtn.Font=Enum.Font.GothamBold; closeBtn.TextSize=16; closeBtn.Parent=titleBar; corner(closeBtn,6)

local toggleBtn=Instance.new("TextButton")
toggleBtn.Name="ToggleFly"; toggleBtn.Size=UDim2.new(1,-16,0,46); toggleBtn.Position=UDim2.new(0,8,0,48)
toggleBtn.BackgroundColor3=C_PRIMARY; toggleBtn.TextColor3=C_TEXT; toggleBtn.TextSize=18; toggleBtn.Font=Enum.Font.GothamBold; toggleBtn.AutoButtonColor=true
toggleBtn.Text="Enable Fly"; toggleBtn.Parent=panel; corner(toggleBtn,8)

local collapsedBtn=Instance.new("TextButton")
collapsedBtn.Name="Collapsed"; collapsedBtn.Size=UDim2.fromOffset(46,46); collapsedBtn.AnchorPoint=Vector2.new(0.5,1); collapsedBtn.Position=panel.Position
collapsedBtn.BackgroundColor3=C_PRIMARY; collapsedBtn.Text="+"; collapsedBtn.TextColor3=C_TEXT; collapsedBtn.TextSize=22; collapsedBtn.Font=Enum.Font.GothamBold
collapsedBtn.Visible=false; collapsedBtn.Parent=gui; corner(collapsedBtn,12)

local function setPanelOpen(open)
    panelOpen=open; panel.Visible=open; collapsedBtn.Visible=not open; collapseBtn.Text=open and "-" or "+"; if open then panel.Position=collapsedBtn.Position else lastPanelPos=panel.Position; collapsedBtn.Position=lastPanelPos end
end
collapseBtn.MouseButton1Click:Connect(function() setPanelOpen(false) end)
collapsedBtn.MouseButton1Click:Connect(function() if collapsedBtn:GetAttribute("SuppressNextClick") then collapsedBtn:SetAttribute("SuppressNextClick",false) return end setPanelOpen(true) end)

-- Drag (open)
local dragging,dragStart,startPos
local function enableDrag(handle)
    handle.InputBegan:Connect(function(input)
        if not panelOpen then return end
        if input.UserInputType==Enum.UserInputType.MouseButton1 or input.UserInputType==Enum.UserInputType.Touch then
            dragging=true; dragStart=input.Position; startPos=panel.Position
            local con; con=input.Changed:Connect(function() if input.UserInputState==Enum.UserInputState.End then dragging=false if con then con:Disconnect() end end end)
        end
    end)
    handle.InputChanged:Connect(function(input)
        if not dragging then return end
        if input.UserInputType==Enum.UserInputType.MouseMovement or input.UserInputType==Enum.UserInputType.Touch then
            local d=input.Position-dragStart; panel.Position=UDim2.new(startPos.X.Scale,startPos.X.Offset+d.X,startPos.Y.Scale,startPos.Y.Offset+d.Y); lastPanelPos=panel.Position
        end
    end)
end
enableDrag(titleBar); enableDrag(toggleBtn)

-- Drag (closed +)
collapsedBtn:SetAttribute("SuppressNextClick",false)
local cDragging,cDragStart,cStartPos,cMoved,cPressT
collapsedBtn.InputBegan:Connect(function(input)
    if panelOpen then return end
    if input.UserInputType==Enum.UserInputType.MouseButton1 or input.UserInputType==Enum.UserInputType.Touch then
        cDragging=true; cMoved=false; cPressT=os.clock(); cDragStart=input.Position; cStartPos=collapsedBtn.Position
        local con; con=input.Changed:Connect(function() if input.UserInputState==Enum.UserInputState.End then cDragging=false if con then con:Disconnect() end end end)
    end
end)
collapsedBtn.InputChanged:Connect(function(input)
    if not cDragging or panelOpen then return end
    if input.UserInputType==Enum.UserInputType.MouseMovement or input.UserInputType==Enum.UserInputType.Touch then
        local d=input.Position-cDragStart
        if not cMoved and (d.Magnitude>6 or (os.clock()-cPressT)>0.12) then cMoved=true; collapsedBtn:SetAttribute("SuppressNextClick",true) end
        if cMoved then collapsedBtn.Position=UDim2.new(cStartPos.X.Scale,cStartPos.X.Offset+d.X,cStartPos.Y.Scale,cStartPos.Y.Offset+d.Y) end
    end
end)

-- Controls
local controls
local function getMoveVector()
    if controls then return controls:GetMoveVector() end
    local ps=player:FindFirstChild("PlayerScripts"); local pm=ps and ps:FindFirstChild("PlayerModule")
    if pm then controls=require(pm):GetControls(); return controls:GetMoveVector() end
    return Vector3.zero
end

-- Flight
local rootAttachment,alignOrientation,linearVelocity,liftForce
local flyConn,hDiedConn,loaderConn
local function cleanFly() if flyConn then flyConn:Disconnect() flyConn=nil end; if alignOrientation then alignOrientation:Destroy() alignOrientation=nil end; if linearVelocity then linearVelocity:Destroy() linearVelocity=nil end; if liftForce then liftForce:Destroy() liftForce=nil end; if rootAttachment then rootAttachment:Destroy() rootAttachment=nil end; if humanoid then humanoid.AutoRotate=true end end
local function desiredDirFromInput(camCF)
    local mv=getMoveVector()
    if controlMode=="keyboard" then
        local forward=-mv.Z; local strafe=mv.X
        local d=camCF.RightVector*strafe + camCF.LookVector*forward
        return (d.Magnitude>1e-3) and d.Unit or Vector3.zero
    else
        local forward=math.max(0,-mv.Z); local strafe=mv.X
        local d=camCF.RightVector*strafe + camCF.LookVector*forward
        return (d.Magnitude>1e-3) and d.Unit or Vector3.zero
    end
end
local function startFlying()
    if flying then return end
    flying=true; toggleBtn.Text="Disable Fly"; toggleBtn.BackgroundColor3=C_STOP
    rootAttachment=Instance.new("Attachment"); rootAttachment.Name="FlyAttachment"; rootAttachment.Parent=hrp
    alignOrientation=Instance.new("AlignOrientation"); alignOrientation.Attachment0=rootAttachment; alignOrientation.Mode=Enum.OrientationAlignmentMode.OneAttachment; alignOrientation.Responsiveness=60; alignOrientation.MaxTorque=math.huge; alignOrientation.Parent=hrp
    linearVelocity=Instance.new("LinearVelocity"); linearVelocity.Attachment0=rootAttachment; linearVelocity.MaxForce=math.huge; linearVelocity.RelativeTo=Enum.ActuatorRelativeTo.World; linearVelocity.VectorVelocity=Vector3.zero; linearVelocity.Parent=hrp
    liftForce=Instance.new("VectorForce"); liftForce.Attachment0=rootAttachment; liftForce.RelativeTo=Enum.ActuatorRelativeTo.World; liftForce.Force=Vector3.zero; liftForce.Parent=hrp
    humanoid.AutoRotate=false
    flyConn=RunService.RenderStepped:Connect(function()
        if not flying then return end
        local cam=workspace.CurrentCamera; local camCF=(cam and cam.CFrame) or hrp.CFrame
        local dir=desiredDirFromInput(camCF)
        linearVelocity.VectorVelocity=dir*speed
        local face=(dir.Magnitude>1e-3) and dir or camCF.LookVector
        alignOrientation.CFrame=CFrame.lookAt(hrp.Position,hrp.Position+face)
        liftForce.Force=Vector3.new(0,hrp.AssemblyMass*workspace.Gravity,0)
        if humanoid:GetState()~=Enum.HumanoidStateType.Freefall then humanoid:ChangeState(Enum.HumanoidStateType.Freefall) end
    end)
end
local function stopFlying() if not flying then return end flying=false; toggleBtn.Text="Enable Fly"; toggleBtn.BackgroundColor3=C_PRIMARY; cleanFly() end

-- Death auto-stop
local function hookHumanoid(h) if hDiedConn then hDiedConn:Disconnect() hDiedConn=nil end; hDiedConn=h.Died:Connect(function() if flying then print("[MobileFly] Player died: stopping fly") end; stopFlying() end) end
hookHumanoid(humanoid)

-- Buttons
toggleBtn.MouseButton1Click:Connect(function() if flying then stopFlying() else startFlying() end end)
closeBtn.MouseButton1Click:Connect(function()
    if flying then stopFlying() end
    if loaderConn then loaderConn:Disconnect() loaderConn=nil end
    if gui then gui:Destroy() end
    _G.MobileFly=nil
    print("[MobileFly] Closed: destroying script")
    task.defer(function() if script and script.Destroy then script:Destroy() end end)
end)

-- Respawn
player.CharacterAdded:Connect(function(c)
    character=c; hrp=c:WaitForChild("HumanoidRootPart"); humanoid=c:WaitForChild("Humanoid"); hookHumanoid(humanoid)
    if flying then cleanFly() task.wait(0.15) startFlying() end
end)

-- Loader (3 dots + input detect)
panel.Visible=false; collapsedBtn.Visible=false
local loader=Instance.new("Frame"); loader.Name="Loader"; loader.AnchorPoint=Vector2.new(0.5,0.5); loader.Position=UDim2.new(0.5,0,0.5,0); loader.Size=UDim2.fromOffset(120,40); loader.BackgroundTransparency=1; loader.Parent=gui
local function mkDot(x) local d=Instance.new("Frame"); d.Size=UDim2.fromOffset(12,12); d.Position=UDim2.new(0, x, 0.5, 0); d.AnchorPoint=Vector2.new(0,0.5); d.BackgroundColor3=C_PRIMARY; d.BorderSizePixel=0; d.Parent=loader; corner(d,6); return d end
local d1=mkDot(24); local d2=mkDot(54); local d3=mkDot(84)
local startT=os.clock()
loaderConn=RunService.RenderStepped:Connect(function()
    local t=os.clock()-startT
    local function y(ph) return math.sin((t*6)+ph)*6 end
    d1.Position=UDim2.new(0,24,0.5,y(0))
    d2.Position=UDim2.new(0,54,0.5,y(0.5))
    d3.Position=UDim2.new(0,84,0.5,y(1))
end)

-- Decide input mode
local decided=false
local keyConn,touchConn,inputConn
local function decide(mode,why)
    if decided then return end
    decided=true; controlMode=mode; print("[MobileFly] Mode:",mode,"(",why,")")
    if loaderConn then loaderConn:Disconnect() loaderConn=nil end
    if keyConn then keyConn:Disconnect() keyConn=nil end
    if touchConn then touchConn:Disconnect() touchConn=nil end
    if inputConn then inputConn:Disconnect() inputConn=nil end
    if loader then loader:Destroy() end
    title.Text=(mode=="keyboard") and "Fly (Keyboard)" or "Fly (Mobile)"
    setPanelOpen(true)
end

keyConn=UIS.InputBegan:Connect(function(i,gp)
    if gp then return end
    if i.UserInputType==Enum.UserInputType.Keyboard then decide("keyboard","keyboard press") end
end)
touchConn=UIS.TouchStarted:Connect(function() decide("mobile","touch") end)
inputConn=UIS.InputBegan:Connect(function(i,gp)
    if gp then return end
    if i.UserInputType==Enum.UserInputType.Gamepad1 then decide("keyboard","gamepad favors desktop") end
end)

task.delay(1.2,function()
    if decided then return end
    if UIS.KeyboardEnabled and not UIS.TouchEnabled then decide("keyboard","kb enabled only")
    elseif UIS.TouchEnabled and not UIS.KeyboardEnabled then decide("mobile","touch enabled only")
    else decide("mobile","fallback") end
end)

-- Global
local env=rawget(getfenv() or _G,"_G") or _G
env.MobileFly={
    Toggle=function() if flying then stopFlying() else startFlying() end end,
    Start=startFlying, Stop=stopFlying, IsFlying=function() return flying end,
    SetSpeed=function(v) speed=math.clamp(tonumber(v) or speed,10,300) end,
    OpenUI=function() setPanelOpen(true) end, CloseUI=function() setPanelOpen(false) end,
}

-- Start
setPanelOpen(true) -- will be hidden by loader until decided
panel.Visible=false; collapsedBtn.Visible=false
